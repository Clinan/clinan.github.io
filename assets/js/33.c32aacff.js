(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{478:function(a,t,v){"use strict";v.r(t);var _=v(10),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[a._v("#")]),a._v(" 缓存")]),a._v(" "),v("h2",{attrs:{id:"缓存读写-缓存一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存读写-缓存一致性"}},[a._v("#")]),a._v(" 缓存读写（缓存一致性）")]),a._v(" "),v("h3",{attrs:{id:"旁路缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#旁路缓存"}},[a._v("#")]),a._v(" 旁路缓存")]),a._v(" "),v("p",[v("strong",[a._v("读策略")])]),a._v(" "),v("ol",[v("li",[a._v("从缓存中读取数据")]),a._v(" "),v("li",[a._v("如果缓存命中则直接返回数据")]),a._v(" "),v("li",[a._v("缓存miss，则从数据库中查询数据")])]),a._v(" "),v("p",[v("strong",[a._v("写策略")])]),a._v(" "),v("ol",[v("li",[a._v("更新数据库中的数据")]),a._v(" "),v("li",[a._v("删除缓存记录")])]),a._v(" "),v("h3",{attrs:{id:"写穿-读穿策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#写穿-读穿策略"}},[a._v("#")]),a._v(" 写穿/读穿策略")]),a._v(" "),v("p",[a._v("这个策略的核心原则就是开发者只与缓存打交道，由缓存和数据库通信，写入或者读取数据。这就好比你在汇报工作的时候只对你的直接上级汇报，再由你的直接上级汇报给他的上级，你是不能越级汇报的。")]),a._v(" "),v("h2",{attrs:{id:"缓存的高可用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存的高可用"}},[a._v("#")]),a._v(" 缓存的高可用")]),a._v(" "),v("h3",{attrs:{id:"客户端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[a._v("#")]),a._v(" 客户端")]),a._v(" "),v("p",[a._v("在客户端方案中，你需要关注缓存的写和读两个方面")]),a._v(" "),v("ul",[v("li",[a._v("写入数据时，需要把缓存的数据写入到多个缓存节点中，这叫"),v("strong",[a._v("数据分片")])]),a._v(" "),v("li",[a._v("读取数据时，可以利用多组的缓存做容错，提升缓存系统的可用性。关于读数据，可以使用两种策略\n"),v("ul",[v("li",[a._v("主从")]),a._v(" "),v("li",[a._v("多副本")])])])]),a._v(" "),v("h4",{attrs:{id:"数据分片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据分片"}},[a._v("#")]),a._v(" 数据分片")]),a._v(" "),v("p",[a._v("数据分片算法主要有"),v("strong",[a._v("Hash分片")]),a._v("和"),v("strong",[a._v("一致性Hash分片")])]),a._v(" "),v("p",[v("strong",[a._v("Hash分片")])]),a._v(" "),v("p",[a._v("Hash分片就是对缓存的Key做哈希计算，然后对总的缓存节点取余。")]),a._v(" "),v("p",[a._v("比如我们有3个缓存节点作为一个缓存集群，当有新的数据写入的时候，先对这个key做比如CRC32等hash算法生成Hash值，然后对Hash值对3取余，得到的就是要存入的缓存节点的序号。")]),a._v(" "),v("ul",[v("li",[v("p",[v("strong",[a._v("优点")])]),a._v(" "),v("p",[a._v("简单和容易理解，")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("缺点")])]),a._v(" "),v("p",[a._v("当增加和减少缓存节点的时候，缓存总的节点个数变化造成计算出来的节点序号发生变化，从而导致缓存失效或不可用。")])]),a._v(" "),v("li",[v("p",[v("strong",[a._v("建议")])]),a._v(" "),v("p",[a._v("如果采用这种方法，最好建立在你对于这组缓存命中率下降不敏感，比如还有另外一层缓存兜底的情况下。")])])]),a._v(" "),v("p",[v("strong",[a._v("一致性Hash分片")])]),a._v(" "),v("p",[a._v("一致性分片可以很好的解决增加和删除节点时，命中率下降的问题。")]),a._v(" "),v("p",[v("strong",[a._v("一致性hash虚拟节点")])]),a._v(" "),v("p",[a._v("极端情况下，比如三个节点ABC承担整体的访问，每个节点的访问量平均，A故障后，B将承受双倍的压力（A和B的全部请求，当B承担不了流量Crash后，C也将因为承担原先三倍的流量而Crash，这就造成了整体缓存系统的雪崩。")]),a._v(" "),v("p",[a._v("在一致性Hash算法中引入"),v("strong",[a._v("虚拟节点")]),a._v("的概念。它将一个节点计算多个Hash值，分散到圆环的不同位置，这样实现了数据的平均，当某一个节点故障或者退出的时候，它原先承担的Key将以更将平均的方式分配到其他节点上。从而避免雪崩。")]),a._v(" "),v("p",[v("strong",[a._v("脏数据问题，使用一致性Hash算法一定要设置过期时间")])]),a._v(" "),v("h3",{attrs:{id:"代理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代理"}},[a._v("#")]),a._v(" 代理")]),a._v(" "),v("ol",[v("li",[v("code",[a._v("facebook")]),a._v("的"),v("code",[a._v("mcrouter")])]),a._v(" "),v("li",[v("code",[a._v("twitter")]),a._v("的"),v("code",[a._v("Twemproxy")])]),a._v(" "),v("li",[a._v("豌豆荚的"),v("code",[a._v("Codis")])])]),a._v(" "),v("h3",{attrs:{id:"服务器端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务器端"}},[a._v("#")]),a._v(" 服务器端")]),a._v(" "),v("p",[a._v("主要指redis的sentinel高可用解决方案。")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.clinan.xyz/redis-sentinel.png",alt:""}})]),a._v(" "),v("h2",{attrs:{id:"缓存问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存问题"}},[a._v("#")]),a._v(" 缓存问题")]),a._v(" "),v("h3",{attrs:{id:"缓存雪崩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[a._v("#")]),a._v(" 缓存雪崩")]),a._v(" "),v("h4",{attrs:{id:"现象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#现象"}},[a._v("#")]),a._v(" 现象")]),a._v(" "),v("p",[a._v("指缓存中的数据大批量到过期时间，而查询量巨大，引起数据库压力过大或宕机。")]),a._v(" "),v("h4",{attrs:{id:"解决方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),v("ol",[v("li",[a._v("缓存数据的过期时间要加上随机值，防止同一时间大量数据过期现象发生。")]),a._v(" "),v("li",[a._v("如果缓存是分布式部署。将热点数据均匀分布在不同的缓存数据库中。")]),a._v(" "),v("li",[a._v("设置热点数据永不过期。")])]),a._v(" "),v("h3",{attrs:{id:"缓存穿透"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[a._v("#")]),a._v(" 缓存穿透")]),a._v(" "),v("h4",{attrs:{id:"现象-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#现象-2"}},[a._v("#")]),a._v(" 现象")]),a._v(" "),v("p",[a._v("缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。")]),a._v(" "),v("h4",{attrs:{id:"解决方案-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),v("ol",[v("li",[a._v("如果可以将ID指定在有效范围内的才能访问数据库。")]),a._v(" "),v("li",[a._v("布隆过滤器，一个byte数组，根据数据量多少决定大小。")]),a._v(" "),v("li",[a._v("回种空值。")])]),a._v(" "),v("h3",{attrs:{id:"缓存击穿-极热点数据-狗桩效应"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿-极热点数据-狗桩效应"}},[a._v("#")]),a._v(" 缓存击穿（极热点数据）（狗桩效应）")]),a._v(" "),v("h4",{attrs:{id:"现象-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#现象-3"}},[a._v("#")]),a._v(" 现象")]),a._v(" "),v("p",[a._v("是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。")]),a._v(" "),v("h4",{attrs:{id:"解决方案-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-3"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),v("ol",[v("li",[a._v("在某一个热点缓存项失效后启动一个后台线程，穿透到数据库。将数据加载到缓存中，在缓存未加载之前，所有请求直接返回。")]),a._v(" "),v("li",[a._v("在redis中设置分布式锁，只有获取到锁的请求才能穿透到数据库。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);