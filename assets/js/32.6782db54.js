(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{477:function(_,v,t){"use strict";t.r(v);var a=t(10),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"阿里亿级高并发系统设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#阿里亿级高并发系统设计"}},[_._v("#")]),_._v(" 阿里亿级高并发系统设计")]),_._v(" "),t("h2",{attrs:{id:"数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[_._v("#")]),_._v(" 数据库")]),_._v(" "),t("h3",{attrs:{id:"数据库连接池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据库连接池"}},[_._v("#")]),_._v(" 数据库连接池")]),_._v(" "),t("p",[_._v("最小连接数和最大连接数")]),_._v(" "),t("ul",[t("li",[_._v("如果当前连接数小于最小连接数，则创建新的连接处理数据库请求")]),_._v(" "),t("li",[_._v("如果连接池中有空闲连接则复用空闲连接")]),_._v(" "),t("li",[_._v("如果空闲池中没有连接并且连接数小于最大连接数，则创建新的连接处理请求")]),_._v(" "),t("li",[_._v("如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间，等待空闲连接可用，超时则抛出错误。")])]),_._v(" "),t("h3",{attrs:{id:"读写分离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读写分离"}},[_._v("#")]),_._v(" 读写分离")]),_._v(" "),t("ul",[t("li",[_._v("一般一个主库最多挂3~5个从库")])]),_._v(" "),t("h3",{attrs:{id:"写入数据量增加时-如何实现分库分表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写入数据量增加时-如何实现分库分表"}},[_._v("#")]),_._v(" 写入数据量增加时，如何实现分库分表")]),_._v(" "),t("h4",{attrs:{id:"垂直分表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垂直分表"}},[_._v("#")]),_._v(" 垂直分表")]),_._v(" "),t("p",[_._v("一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的"),t("strong",[_._v("商品描述")]),_._v("。所以，当表数据量很大时，可以"),t("strong",[_._v("将表按字段切开，将热门字段、冷门字段分开放置在不同库中")]),_._v("，这些库可以放在不同的存储设备上，避免IO争抢。垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。")]),_._v(" "),t("p",[_._v("通常我们按以下原则进行垂直拆分:")]),_._v(" "),t("ol",[t("li",[_._v("把不常用的字段单独放在一张表;")]),_._v(" "),t("li",[_._v("把text，blob等大字段拆分出来放在附表中;")]),_._v(" "),t("li",[_._v("经常组合查询的列放在一张表中;")])]),_._v(" "),t("h4",{attrs:{id:"垂直分库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垂直分库"}},[_._v("#")]),_._v(" 垂直分库")]),_._v(" "),t("p",[t("strong",[_._v("垂直分库")]),_._v("是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。")]),_._v(" "),t("p",[_._v("它带来的提升是：")]),_._v(" "),t("ul",[t("li",[_._v("解决业务层面的耦合，业务清晰")]),_._v(" "),t("li",[_._v("能对不同业务的数据进行分级管理、维护、监控、扩展等")]),_._v(" "),t("li",[_._v("高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈")])]),_._v(" "),t("p",[_._v("垂直分库通过将表按"),t("strong",[_._v("业务分类")]),_._v("，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题。")]),_._v(" "),t("h4",{attrs:{id:"水平分库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#水平分库"}},[_._v("#")]),_._v(" 水平分库")]),_._v(" "),t("p",[_._v("是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。")]),_._v(" "),t("h4",{attrs:{id:"水平分表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#水平分表"}},[_._v("#")]),_._v(" 水平分表")]),_._v(" "),t("p",[_._v("与水平分库的思路类似，不过这次操作的目标是表，商品信息及商品描述被分成了两套表。如果商品ID为双数，将此操作映射至商品信息1表；如果商品ID为单数，将操作映射至商品信息2表。此操作要访问表名称的表达式为"),t("strong",[_._v("商品信息[商品ID%2 + 1]")]),_._v(" 。")]),_._v(" "),t("p",[_._v("小明进行的这一步优化，就叫"),t("strong",[_._v("水平分表")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("水平分表")]),_._v("是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。")]),_._v(" "),t("h4",{attrs:{id:"发号器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发号器"}},[_._v("#")]),_._v(" 发号器")]),_._v(" "),t("p",[_._v("雪花算法")]),_._v(" "),t("h2",{attrs:{id:"缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[_._v("#")]),_._v(" 缓存")]),_._v(" "),t("h3",{attrs:{id:"缓存穿透解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透解决方案"}},[_._v("#")]),_._v(" 缓存穿透解决方案")]),_._v(" "),t("p",[_._v("缓存穿透是指从缓存中没有查到数据，而不得不从数据库中获取。")]),_._v(" "),t("h3",{attrs:{id:"回种空值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回种空值"}},[_._v("#")]),_._v(" 回种空值")]),_._v(" "),t("p",[_._v("当从数据库中查询到空值或发生异常时，我们可以向缓存中回种一个空值，但因为空值不是准确的业务数据，所以我们会给这个空值加一个比较短的过期时间，让空值能够在短时间内快速淘汰。")]),_._v(" "),t("p",[_._v("缺点：当数据量很大的时候，会消耗很多无意义的内存。")]),_._v(" "),t("h3",{attrs:{id:"布隆过滤器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器"}},[_._v("#")]),_._v(" 布隆过滤器")]),_._v(" "),t("p",[_._v("用来判断一个值是否在集合中，由一个二进制数组和Hash算法组成。实际应用来判断一值是否存在数据库中。可能存在和一定不存在的判断。")]),_._v(" "),t("p",[_._v("优点：拥有极高的性能，无论是写入还是读取，时间复杂度都是O(1)")]),_._v(" "),t("p",[_._v("缺点：")]),_._v(" "),t("ul",[t("li",[_._v("判断元素是否在集合中有一定的错误几率，它会把不在集合中的元素判断为在集合中。因为hash碰撞。\n"),t("ul",[t("li",[_._v("解决方案使用多个算法计算多个不同的hash，只有所有hash值对应数组的值都为1，才是存在。")])])]),_._v(" "),t("li",[_._v("不支持删除元素\n"),t("ul",[t("li",[_._v("不是bit数组，而是引用计数。多了一个+1，少了-1。且一般来说存的一般不会删除的数据。")])])])]),_._v(" "),t("h3",{attrs:{id:"极热点场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#极热点场景"}},[_._v("#")]),_._v(" 极热点场景")]),_._v(" "),t("p",[_._v("一个极热点的缓存项，一旦失效会有大量的请求穿透到数据库，会对数据库造成很大的压力。")]),_._v(" "),t("p",[t("strong",[_._v("解决方案")])]),_._v(" "),t("ol",[t("li",[_._v("在代码中，控制在某一热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而直接返回。")]),_._v(" "),t("li",[_._v("通过在"),t("code",[_._v("memcached")]),_._v("或者"),t("code",[_._v("Redis")]),_._v("中设置分布式锁，只有获取到锁的请求才能够穿透到数据库。分布式锁的实现：比方说一个ID=1的用户是热点用户，当他的用户信息缓存失效后，我们需要从数据库重新加载数据时，先向"),t("code",[_._v("Memcached")]),_._v("写入一个"),t("code",[_._v("Key=lock.1")]),_._v("的缓存项，加载完后就删除。另外的线程发现有缓存，就会直接使用这个缓存，就不会穿透到数据库了。")])]),_._v(" "),t("h2",{attrs:{id:"消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[_._v("#")]),_._v(" 消息队列")]),_._v(" "),t("ol",[t("li",[_._v("流量削峰")]),_._v(" "),t("li",[_._v("应用解耦")]),_._v(" "),t("li",[_._v("异步处理")]),_._v(" "),t("li",[_._v("消息通信")])]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("大佬理解：消息队列是一个暂存数据的容器，是一个平衡低速系统和高速系统处理任务时间差的工具。")])])]),_._v(" "),t("h3",{attrs:{id:"秒杀系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#秒杀系统"}},[_._v("#")]),_._v(" 秒杀系统")]),_._v(" "),t("p",[t("strong",[_._v("削去秒杀场景下的峰值写流量")])]),_._v(" "),t("p",[_._v("思路是：将秒杀请求暂存在消息队列中，然后业务服务器响应用户“秒杀结算中”。队列处理机处理秒杀，并持久化到数据库。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.clinan.xyz/mq1.png",alt:""}})]),_._v(" "),t("p",[t("strong",[_._v("通过异步处理简化秒杀请求中的业务流程")])]),_._v(" "),t("p",[_._v("购买流程里，有主要和次要的业务逻辑。在这里主要的逻辑是生成订单，扣减库存；次要的是发放优惠券，增加用户的积分。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.clinan.xyz/mq2.png",alt:""}})]),_._v(" "),t("p",[t("strong",[_._v("解耦实现秒杀系统模块之间松耦合")])]),_._v(" "),t("p",[_._v("可以降低业务系统和数据系统的直接耦合度")]),_._v(" "),t("h3",{attrs:{id:"如何保证消息只被消费一次-幂等性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息只被消费一次-幂等性"}},[_._v("#")]),_._v(" 如何保证消息只被消费一次（幂等性）")]),_._v(" "),t("p",[_._v("消息丢失的三个场景")]),_._v(" "),t("h4",{attrs:{id:"_1-消息从生产者写入消息队列的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-消息从生产者写入消息队列的过程"}},[_._v("#")]),_._v(" 1. 消息从生产者写入消息队列的过程")]),_._v(" "),t("p",[_._v("采用消息重传的方案，发现消息发送超时后，将消息重传，不能无限次重传。2~3次即可")]),_._v(" "),t("h4",{attrs:{id:"_2-消息在消息队列中的存储过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-消息在消息队列中的存储过程"}},[_._v("#")]),_._v(" 2.消息在消息队列中的存储过程")]),_._v(" "),t("p",[_._v("集群部署，主从集群。部署多个副本备份数据，保证消息数据尽量不丢失。")]),_._v(" "),t("h4",{attrs:{id:"_3-信息被消费者消费的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-信息被消费者消费的过程"}},[_._v("#")]),_._v(" 3.信息被消费者消费的过程")]),_._v(" "),t("p",[_._v("消息消费分为三步，接收消息，处理消息，更新消息进度。")]),_._v(" "),t("p",[_._v("如果消息处理后，系统正好宕机了，消息服务器就会重传，但是这样可能会导致消息被多次消费。")]),_._v(" "),t("p",[t("strong",[_._v("解决方案：")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("对于MQ，每个生产者有一个唯一ID+消息的ID，消息队列判断同一个系统最后一个消息ID一样，服务端会自动丢弃")])]),_._v(" "),t("li",[t("p",[_._v("对于消费者："),t("strong",[_._v("乐观锁，加一个version")])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);