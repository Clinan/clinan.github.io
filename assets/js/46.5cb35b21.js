(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{489:function(t,e,s){"use strict";s.r(e);var a=s(10),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"mysql事务的隔离级别-isolation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql事务的隔离级别-isolation"}},[t._v("#")]),t._v(" MYSQL事务的隔离级别（ISOLATION）")]),t._v(" "),s("h2",{attrs:{id:"mysql的级别级别-官方解释和解读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql的级别级别-官方解释和解读"}},[t._v("#")]),t._v(" MYSQL的级别级别（官方解释和解读）")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"left"}},[t._v("级别")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("脏读(dirty read)")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("重复读(Consistent Nonlocking Reads)")]),t._v(" "),s("th",{staticStyle:{"text-align":"left"}},[t._v("幻读(phantom rows)")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("READ UNCOMMITTED")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("true")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("true")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("true")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("READ COMMITTED")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("false")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("true")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("true")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("REPEATABLE READ")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("false")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("false")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("true")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[t._v("SERIALIZABLE")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("false")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("false")]),t._v(" "),s("td",{staticStyle:{"text-align":"left"}},[t._v("false")])])])]),t._v(" "),s("p",[s("strong",[t._v("注： true和false表示是否会导致该问题。")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官网地址"),s("OutboundLink")],1)]),t._v(" "),s("ul",[s("li",[t._v("REPEATABLE READ")])]),t._v(" "),s("p",[t._v("This is the default isolation level for InnoDB. Consistent reads within the same transaction read the snapshot established by the first read. This means that if you issue several plain (nonlocking) SELECT statements within the same transaction, these SELECT statements are consistent also with respect to each other.")]),t._v(" "),s("p",[t._v("For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition.")]),t._v(" "),s("ul",[s("li",[t._v("For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it.")]),t._v(" "),s("li",[t._v("For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key locks to block insertions by other sessions into the gaps covered by the range. For information about gap locks and next-key locks, see Section 15.7.1, “InnoDB Locking”.")])]),t._v(" "),s("p",[t._v("可重复读是MYSQL默认的事务隔离级别，会在事务中第一次查询的时候，生成一个数据库快照。保证每一次读取同一条数据的时候，都是一致的，不会产生重复读同一条数据会返回不同的结果（因为并发，已读过的数据会被其他事务更新掉）的问题。")]),t._v(" "),s("p",[t._v("在使用悲观锁（FOR UPDATE/SHARE）查询或更新删除时，会根据唯一索引或是where条件来锁定列数据，而不是锁定整个表。可以在锁定的"),s("code",[t._v("row")]),t._v("列数据上方或下方插入或删除数据。"),s("code",[t._v("gap locks")]),t._v("间隙锁意思是在索引范围锁，如"),s("code",[t._v("select * from t where id between 1 and 10 for update")]),t._v("那么在1-10这个索引中间，不能插入数据（如原本id=9的记录不存在，现在要插入id=9的记录，也不行）。")]),t._v(" "),s("ul",[s("li",[t._v("READ COMMITTED")])]),t._v(" "),s("p",[t._v("Each consistent read, even within the same transaction, sets and reads its own fresh snapshot. For information about consistent reads, see Section 15.7.2.3, “Consistent Nonlocking Reads”.")]),t._v(" "),s("p",[t._v("For locking reads (SELECT with FOR UPDATE or FOR SHARE), UPDATE statements, and DELETE statements, InnoDB locks only index records, not the gaps before them, and thus permits the free insertion of new records next to locked records. Gap locking is only used for foreign-key constraint checking and duplicate-key checking.")]),t._v(" "),s("p",[t._v("Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps.")]),t._v(" "),s("p",[t._v("Only row-based binary logging is supported with the READ COMMITTED isolation level. If you use READ COMMITTED with binlog_format=MIXED, the server automatically uses row-based logging.")]),t._v(" "),s("p",[s("code",[t._v("READ COMMIT")]),t._v("意思是会读取到已提交的其他事务，在一个事务中，每一次查询都会刷新快照，查询到的始终都是最新的数据，"),s("code",[t._v("Consistent Nonlocking Reads")]),t._v("一致性非锁定读。会出现同样的查询语句，却得到不一样的查询结果（当前事务没有更新操作）。此外"),s("code",[t._v("READ COMMIT")]),t._v("会禁用"),s("code",[t._v("gap locks")]),t._v("。")]),t._v(" "),s("p",[t._v("在使用悲观锁（FOR UPDATE/SHARE）查询或更新删除时，只会锁定符合条件的列，如果要是"),s("code",[t._v("select * from t where id between 1 and 10 for update")]),t._v("（id=9的数据不存在），在这个时候，其他会话是可以插入id=9的数据，两次读取的数据不一致，出现了重复读的问题。")]),t._v(" "),s("ul",[s("li",[t._v("READ UNCOMMITTED")])]),t._v(" "),s("p",[t._v("SELECT statements are performed in a nonlocking fashion, but a possible earlier version of a row might be used. Thus, using this isolation level, such reads are not consistent. This is also called a dirty read. Otherwise, this isolation level works like READ COMMITTED.")]),t._v(" "),s("p",[s("code",[t._v("READ UNCOMMITTED")]),t._v("是事务隔离级别最低，以非锁定的方式执行。如：会话A中可以查询到会话B中更新插入删除的数据，如果B回滚了，那么A读取到就是已经被B回滚掉的脏数据，一般都不会使用这个隔离级别。")]),t._v(" "),s("ul",[s("li",[t._v("SERIALIZABLE")])]),t._v(" "),s("p",[t._v("This level is like REPEATABLE READ, but InnoDB implicitly converts all plain SELECT statements to SELECT ... FOR SHARE if autocommit is disabled. If autocommit is enabled, the SELECT is its own transaction. It therefore is known to be read only and can be serialized if performed as a consistent (nonlocking) read and need not block for other transactions. (To force a plain SELECT to block if other transactions have modified the selected rows, disable autocommit.)")]),t._v(" "),s("p",[s("code",[t._v("SERIALIZABLE")]),t._v("是事务隔离级别中级别最高的，此级别类似于REPEATABLE READ，但是InnoDB将所有普通SELECT 语句隐式转换为SELECT ... FOR SHARE， autocommit禁用。如果 autocommit启用，则 SELECT是其自身的事务。因此，它被认为是只读的，并且如果以一致的（非锁定）读取方式执行并且不需要阻塞其他事务就可以序列化。（SELECT如果其他事务已修改所选行，则要强制平原 阻止，请禁用 autocommit。）")]),t._v(" "),s("h2",{attrs:{id:"幻读和不可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幻读和不可重复读"}},[t._v("#")]),t._v(" 幻读和不可重复读")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("Dirty Reads")]),t._v("： 一个事务还未提交，另外一个事务访问此事务修改的数据，并使用，读取了事务中间状态数据. 脏读，强调的是主事务读取了一个不存在(因回滚而不存在)的数据.")]),t._v(" "),s("li",[s("strong",[t._v("Nonrepeatable Reads")]),t._v("：一个事务读取同一条记录两次("),s("strong",[t._v("第一次读确认数据存在")]),t._v(")，由于两次读取间隔期间，另一个事务对数据进行了修改，使得事务两次读取的结果不一致.")]),t._v(" "),s("li",[s("strong",[t._v("Phantoms")]),t._v("： 事务 A 第一次读取与搜索条件相匹配的若干行不存在. 事务 B 以插入或删除行等方式来修改事务 A 的结果集，然后再提交,　导致事务 A 读取了与第一次结果"),s("strong",[t._v("不一致的数据集")]),t._v(".")])]),t._v(" "),s("h2",{attrs:{id:"查看mysql的事务隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查看mysql的事务隔离级别"}},[t._v("#")]),t._v(" 查看MYSQL的事务隔离级别")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" @"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@tx_isolation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# mysql5.7")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" @"),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@transaction_isolation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# mysql8.0+")]),t._v("\n")])])]),s("h2",{attrs:{id:"设置当前会话的mysql的事务隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设置当前会话的mysql的事务隔离级别"}},[t._v("#")]),t._v(" 设置当前会话的MYSQL的事务隔离级别")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("session")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transaction")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("isolation")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 后面加上上诉的级别 如")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("session")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transaction")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("isolation")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("REPEATABLE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("READ")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"innodb的repeatable-read"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#innodb的repeatable-read"}},[t._v("#")]),t._v(" innodb的Repeatable read")]),t._v(" "),s("p",[t._v("基于MVCC（多版本并发控制），innodb不会出现幻读"),s("br"),t._v("\ninnodb默认会给每个表额外的增加两列，一列保存行的创建时的系统版本号，一列保存行的删除时的系统版本号。\n系统版本号会自动递增。"),s("br"),t._v("\n每次开启新的事务时，当前的系统版本号会作为事务的系统版本号，用来CURD表。"),s("s",[t._v("查到的数据只能是小于或等于当前系统版本号的数据")]),t._v(" "),s("a",{attrs:{href:"https://www.cnblogs.com/eternityz/p/12443278.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("read view"),s("OutboundLink")],1)]),t._v(" "),s("ul",[s("li",[t._v("删除列，将当前版本号设置到删除位上。")]),t._v(" "),s("li",[t._v("插入列，将当前版本号设置到创建位上。")]),t._v(" "),s("li",[t._v("更新列，插入一条新的数据，并标识删除旧的数据。")])]),t._v(" "),s("h3",{attrs:{id:"readview"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#readview"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://blog.csdn.net/Waves___/article/details/105295060",target:"_blank",rel:"noopener noreferrer"}},[t._v("readview"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/",target:"_blank",rel:"noopener noreferrer"}},[t._v("其他博客"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("对于当前事务的启动瞬间来说，假设当前trx id为98 ， 在当前事务开始后，计算活跃事务之前又产生了个新事务trx id为99没有commit，假设活跃事务的id组成的数据为下面的数组[80,88,99]，此时事务80/88/99为活跃事务，99为当前系统中事务最大ID, 高水位100是当前系统最大事务id99加1计算出来的,则会有以下几种可能:")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的; 即80以前的事务都可见")])]),t._v(" "),s("li",[s("p",[t._v("如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的; 100及100以后的事务都不可见")])]),t._v(" "),s("li",[s("p",[t._v("如果落在黄色部分，那就包括两种情况")]),t._v(" "),s("p",[t._v("a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见; 80/88/99为活跃事务，不可见")]),t._v(" "),s("p",[t._v("b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。80~99中间，去除80/88/99，比如81等其余的是可见的.")])])]),t._v(" "),s("h2",{attrs:{id:"锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("数据库事务隔离级别越高，说明涉及到的锁越多，发生死锁的可能性越大，同时锁多了会影响数据库的并发性能，一般来说使用默认的"),s("code",[t._v("REPEATABLE READ")]),t._v("是最好的。其次就是"),s("code",[t._v("READ COMMITTED")]),t._v("，最高的和最低的，最好都不要设置。")])])}),[],!1,null,null,null);e.default=n.exports}}]);