(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{493:function(e,t,a){"use strict";a.r(t);var v=a(10),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"netty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[e._v("#")]),e._v(" Netty")]),e._v(" "),a("h2",{attrs:{id:"netty的优点和比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#netty的优点和比较"}},[e._v("#")]),e._v(" netty的优点和比较")]),e._v(" "),a("h3",{attrs:{id:"为什么选择netty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么选择netty"}},[e._v("#")]),e._v(" 为什么选择netty")]),e._v(" "),a("ul",[a("li",[e._v("支持重用应用层协议，http/smtp/http2等等")]),e._v(" "),a("li",[e._v("解决传输问题：粘包、半包现象")]),e._v(" "),a("li",[e._v("支持流量整形；")]),e._v(" "),a("li",[e._v("完善的断连、Idle等异常处理等。")])]),e._v(" "),a("h3",{attrs:{id:"为什么不用jdk的nio"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不用jdk的nio"}},[e._v("#")]),e._v(" 为什么不用jdk的NIO")]),e._v(" "),a("ul",[a("li",[e._v("JDKNIO有BUG，使用netty可以规避BUG")]),e._v(" "),a("li",[e._v("API更友好更强大，比如ThreadLocal->FastThreadLocal")]),e._v(" "),a("li",[e._v("隔离物理硬件的差异，屏蔽细节。")])]),e._v(" "),a("h2",{attrs:{id:"基本概念介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念介绍"}},[e._v("#")]),e._v(" 基本概念介绍")]),e._v(" "),a("h3",{attrs:{id:"bio-nio-bio的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bio-nio-bio的区别"}},[e._v("#")]),e._v(" BIO NIO, BIO的区别")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("BIO也称为OIO，也就是传统的一个线程对应一个TCP链接（socket)。它是阻塞同步。如果有N个连接连到服务上，就会创建N个线程")])]),e._v(" "),a("li",[a("p",[e._v("NIO是多路复用，一个线程处理多个socket链接。是非阻塞同步。\n在NIO中，一个线程对对应多个socket连接。NIO还分为两种，一种是传统poll（Linux）还有一种是Epoll")])]),e._v(" "),a("li",[a("p",[e._v("AIO它是非阻塞同步的。")])])]),e._v(" "),a("p",[e._v("举个例子。\n吃饭场景")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("排队打饭，自选模式。他需要排队，并且需要自己拿菜。BIO，他需要排队（阻塞），同时还要自己去端菜。")])]),e._v(" "),a("li",[a("p",[e._v("点单，下单了之后，厨房做好。然后叫号让自己去端菜。NIO，他不需要排队（阻塞），但是需要自己去端菜。")])]),e._v(" "),a("li",[a("p",[e._v("包厢模式，下单之后，厨房做好，然后服务员给你端上来。AIO，既不需要排队，也不需要自己去端菜。")])])]),e._v(" "),a("h3",{attrs:{id:"阻塞和同步的概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞和同步的概念"}},[e._v("#")]),e._v(" 阻塞和同步的概念")]),e._v(" "),a("p",[e._v("阻塞就是要排队。任务全都是当前线程处理，遇到IO，自身是等待的\n非阻塞就是不要排队。然后坐着等菜做好。也就是点单之后，交给其他人处理，自己坐下来歇着。IO的话，不等待，直接返回。")]),e._v(" "),a("p",[a("strong",[e._v("同步与异步的判断，取决于要不要自己端菜，")])]),e._v(" "),a("ul",[a("li",[e._v("同步就是自己端菜，数据自己读取。")]),e._v(" "),a("li",[e._v("异步就是服务员端菜。具体就是系统把数据准备好，然后回调给你")])]),e._v(" "),a("p",[e._v("对于netty来说，它是支持NIO，也支持AIO以及BIO。但是由于AIO在Linux下性能不好，所以移除了。")]),e._v(" "),a("h3",{attrs:{id:"nio-三种reactor模式。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nio-三种reactor模式。"}},[e._v("#")]),e._v(" NIO 三种reactor模式。")]),e._v(" "),a("ol",[a("li",[e._v("的话就是单线程的reactor")]),e._v(" "),a("li",[e._v("就是多线程的reactor")]),e._v(" "),a("li",[e._v("主从的reactor模式，boss线程和worker线程")])]),e._v(" "),a("p",[a("strong",[e._v("举个例子")])]),e._v(" "),a("p",[e._v("酒店的工作流程。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("单线程的reactor模式来说，就是酒店只有一个服务员，他负责所有的任务，迎宾，点菜，做菜，上菜，送客等操作。")])]),e._v(" "),a("li",[a("p",[e._v("多线程的reactor模式，就是酒店多招了几个人，这些和单线程的服务员，都要走所有流程。")])]),e._v(" "),a("li",[a("p",[e._v("主从的reactor模式，boss负责迎宾，然后服务员们来点菜，做菜，上菜，送客等操作。")])])]),e._v(" "),a("h2",{attrs:{id:"channel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[e._v("#")]),e._v(" Channel")]),e._v(" "),a("p",[e._v("它代表一个到实体的关系（如一个硬件设备、一个文件或多个不同的I/O操作的程序组件）的开发连接，如读写操作。")]),e._v(" "),a("p",[e._v("可以把Channel看成出站和入站数据的载体。特点是可以被打开或者被关闭，连接或者断开连接。")]),e._v(" "),a("p",[e._v("在服务器中，Channel主要有两种类型")]),e._v(" "),a("ul",[a("li",[e._v("监听socket连接的Channel，在Netty中就是ServerSocketChannel")]),e._v(" "),a("li",[e._v("监听客户端数据的Channel，在Netty中就是SocketChannel(childChannel)")])]),e._v(" "),a("p",[e._v("例如，服务器监听一个端口，就是一个"),a("code",[e._v("Channel")]),e._v("。与每一个客户端连接（"),a("code",[e._v("socket")]),e._v("）形成一个通信"),a("code",[e._v("Channel")]),e._v("。也就是"),a("code",[e._v("childChannel")])]),e._v(" "),a("h3",{attrs:{id:"channel的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#channel的类型"}},[e._v("#")]),e._v(" Channel的类型")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("NIO")]),e._v("。基于JavaNIO")]),e._v(" "),a("li",[a("code",[e._v("Epoll")]),e._v("。基于Linux的Epoll")]),e._v(" "),a("li",[a("code",[e._v("OIO")]),e._v("（BIO）。Old I/O，指阻塞I/O")]),e._v(" "),a("li",[a("code",[e._v("Local")]),e._v("。JVM通信")]),e._v(" "),a("li",[a("code",[e._v("Embedded")]),e._v("。用于测试"),a("code",[e._v("ChannelHandler")])])]),e._v(" "),a("h2",{attrs:{id:"eventloop和线程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eventloop和线程模型"}},[e._v("#")]),e._v(" EventLoop和线程模型")]),e._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210727142100694.png",alt:"image-20210727142100694"}})]),e._v(" "),a("p",[e._v("每个EventLoop都对应了一个线程"),a("code",[e._v("EventExecutor(EventLoop的父类)")]),e._v("，这个每个channel都会绑定一个"),a("code",[e._v("EventLoop")]),e._v("，不同的Channel可以是相同的"),a("code",[e._v("EventLoop")])]),e._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210727141131652.png",alt:"image-20210727141131652"}})]),e._v(" "),a("h2",{attrs:{id:"bytebuf-数据容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytebuf-数据容器"}},[e._v("#")]),e._v(" "),a("code",[e._v("ByteBuf")]),e._v(" -数据容器")]),e._v(" "),a("p",[a("code",[e._v("ByteBuf")]),e._v("是Java NIO的ByteBuffer替代者。")]),e._v(" "),a("h3",{attrs:{id:"如何工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何工作"}},[e._v("#")]),e._v(" 如何工作")]),e._v(" "),a("p",[a("code",[e._v("ByteBuf")]),e._v(" 维护了两个不同的索引：一个用于读取，一个用于写入。当你从"),a("code",[e._v("ByteBuf")]),e._v(" 读取时，它的"),a("code",[e._v("readerIndex")]),e._v(" 将会被递增已经被读取的字节数。同样地，当你写入"),a("code",[e._v("ByteBuf")]),e._v(" 时，它的"),a("code",[e._v("writerIndex")]),e._v(" 也会被递增。下图展示了一个空"),a("code",[e._v("ByteBuf")]),e._v(" 的布局结构和状态。")]),e._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210727143246911.png",alt:"image-20210727143246911"}})]),e._v(" "),a("p",[e._v("名称以"),a("code",[e._v("read")]),e._v("或者"),a("code",[e._v("write")]),e._v("开头"),a("code",[e._v("ByteBut")]),e._v("⽅法将会推进其对应的索引，⽽名称以"),a("code",[e._v("get")]),e._v("或"),a("code",[e._v("set")]),e._v("开头的方法则不会。")]),e._v(" "),a("h3",{attrs:{id:"bytebuf的使用模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytebuf的使用模式"}},[e._v("#")]),e._v(" ByteBuf的使用模式")]),e._v(" "),a("h4",{attrs:{id:"堆缓冲区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆缓冲区"}},[e._v("#")]),e._v(" 堆缓冲区")]),e._v(" "),a("p",[e._v("也被称为支撑数组。最常用"),a("code",[e._v("ByteBuf")]),e._v("的模式，是将数据存储在JVM的堆空间中。")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[e._v(" 判断是不是支撑数组\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ByteBuf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("hasArray")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n 获得支撑数组\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" bytes "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ByteBuf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("array")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("h4",{attrs:{id:"直接缓冲区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#直接缓冲区"}},[e._v("#")]),e._v(" 直接缓冲区")]),e._v(" "),a("p",[e._v("分配的是"),a("code",[e._v("JavaNIO")]),e._v("中的内存缓冲区。也就是直接内存，不是JVM中的堆内存。")]),e._v(" "),a("h4",{attrs:{id:"复合缓冲区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复合缓冲区"}},[e._v("#")]),e._v(" 复合缓冲区")]),e._v(" "),a("p",[e._v("它为多个"),a("code",[e._v("ByteBuf")]),e._v(" 提供一个聚合视图。在这里你可以根据需要添加或者删除"),a("code",[e._v("ByteBuf")]),e._v(" 实例，这是一个JDK 的"),a("code",[e._v("ByteBuffer")]),e._v(" 实现完全缺失的特性。\nNetty 通过一个"),a("code",[e._v("ByteBuf")]),e._v(" 子类—"),a("code",[e._v("CompositeByteBuf")]),e._v("—实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。")]),e._v(" "),a("p",[e._v("举例：如果HTTP分为头部和消息内容，但是对于多个HTTP的请求来说，可能头部是一样的。所以可以重用头部的"),a("code",[e._v("ByteBuf")]),e._v("，避免没必要的复制。在发送的时候，将重用的头部和消息内容放到一个"),a("code",[e._v("CompositeByteBuf")]),e._v("中，发送出去既可。")]),e._v(" "),a("blockquote",[a("p",[a("code",[e._v("CompositeByteBuf")]),e._v(" 中的"),a("code",[e._v("ByteBuf")]),e._v(" 实例可能同时包含"),a("strong",[e._v("直接内存")]),e._v("分配和"),a("strong",[e._v("非直接内存")]),e._v("分配。如果其中只有一个实例，那么对"),a("code",[e._v("CompositeByteBuf")]),e._v(" 上的"),a("code",[e._v("hasArray()")]),e._v("方法的调用将返回该组件上的"),a("code",[e._v("hasArray()")]),e._v("方法的值；否则它将返回false。")])]),e._v(" "),a("p",[e._v("需要注意的是，"),a("code",[e._v("Netty")]),e._v("使用了"),a("code",[e._v("CompositeByteBuf")]),e._v("来优化套接字的I/O操作，尽可能地消除了由JDK的缓冲区实现所导致的性能以及内存使用率的惩罚。这种优化发生在"),a("code",[e._v("Netty")]),e._v("的核心代码中，因此不会被暴露出来，但是你应该知道它所带来的影响。")]),e._v(" "),a("h3",{attrs:{id:"字节操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字节操作"}},[e._v("#")]),e._v(" 字节操作")]),e._v(" "),a("h4",{attrs:{id:"随机访问索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#随机访问索引"}},[e._v("#")]),e._v(" 随机访问索引")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[e._v("byteBuf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("getByte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("h4",{attrs:{id:"顺序访问索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#顺序访问索引"}},[e._v("#")]),e._v(" 顺序访问索引")]),e._v(" "),a("p",[e._v("下图展示了"),a("code",[e._v("ByteBuf")]),e._v(" 是如何被它的两个索引划分成3 个区域的。")]),e._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210727150852360.png",alt:"image-20210727150852360"}})]),e._v(" "),a("h4",{attrs:{id:"可丢弃字节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可丢弃字节"}},[e._v("#")]),e._v(" 可丢弃字节")]),e._v(" "),a("p",[e._v("可丢弃字节的分段包含了已经被读过的字节。通过调用"),a("code",[e._v("discardReadBytes()")]),e._v("方法，可以丢弃它们并回收空间。这个分段的初始大小为0，存储在"),a("code",[e._v("readerIndex")]),e._v(" 中，会随着"),a("code",[e._v("read")]),e._v(" 操作的执行而增加（"),a("code",[e._v("get")]),e._v("操作不会移动"),a("code",[e._v("readerIndex")]),e._v("）。")]),e._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210727151203919.png",alt:"image-20210727151203919"}})]),e._v(" "),a("blockquote",[a("p",[e._v("虽然你可能会倾向于频繁地调用"),a("code",[e._v("discardReadBytes()")]),e._v("方法以确保可写分段的最大化，但是请注意，这将极有可能会导致内存复制，因为可读字节（图中标记为CONTENT 的部分）必须被移动到缓冲区的开始位置。我们建议只在有真正需要的时候才这样做，例如，当内存非常宝贵的时候。")])]),e._v(" "),a("h4",{attrs:{id:"可读字节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可读字节"}},[e._v("#")]),e._v(" 可读字节")]),e._v(" "),a("h4",{attrs:{id:"可写字节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可写字节"}},[e._v("#")]),e._v(" 可写字节")]),e._v(" "),a("h4",{attrs:{id:"索引管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引管理"}},[e._v("#")]),e._v(" 索引管理")]),e._v(" "),a("p",[a("code",[e._v("JDK")]),e._v(" 的"),a("code",[e._v("InputStream")]),e._v(" 定义了"),a("code",[e._v("mark(int readlimit)")]),e._v("和"),a("code",[e._v("reset()")]),e._v("方法，这些方法分别被用来将流中的当前位置标记为指定的值，以及将流重置到该位置。")]),e._v(" "),a("p",[e._v("同样，可以通过调用"),a("code",[e._v("markReaderIndex()")]),e._v("、"),a("code",[e._v("markWriterIndex()")]),e._v("、"),a("code",[e._v("resetWriterIndex()")]),e._v("和"),a("code",[e._v("resetReaderIndex()")]),e._v("来标记和重置"),a("code",[e._v("ByteBuf")]),e._v(" 的"),a("code",[e._v("readerIndex")]),e._v(" 和"),a("code",[e._v("writerIndex")]),e._v("。这些和"),a("code",[e._v("InputStream")]),e._v(" 上的调用类似，只是没有"),a("code",[e._v("readlimit")]),e._v(" 参数来指定标记什么时候失效。也可以通过调用"),a("code",[e._v("readerIndex(int)")]),e._v("或者"),a("code",[e._v("writerIndex(int)")]),e._v("来将索引移动到指定位置。试图将任何一个索引设置到一个无效的位置都将导致一个"),a("code",[e._v("IndexOutOfBoundsException")]),e._v("。可以通过调用clear()方法来将"),a("code",[e._v("readerIndex")]),e._v(" 和"),a("code",[e._v("writerIndex")]),e._v(" 都设置为0。注意，这并不会清除内存中的内容。")]),e._v(" "),a("h4",{attrs:{id:"查找操作bytebufprocessor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查找操作bytebufprocessor"}},[e._v("#")]),e._v(" 查找操作ByteBufProcessor")]),e._v(" "),a("p",[e._v("在"),a("code",[e._v("ByteBuf")]),e._v("中有多种可以用来确定指定值的索引的方法。最简单的是使用"),a("code",[e._v("indexOf()")]),e._v("方法。较复杂的查找可以通过那些需要一个"),a("code",[e._v("ByteBufProcessor")]),e._v("作为参数的方法达成。这个接口只定义了一个方法：")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("process")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("byte")]),e._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("它将检查输入值是否是正在查找的值。")]),e._v(" "),a("h4",{attrs:{id:"派生缓冲区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#派生缓冲区"}},[e._v("#")]),e._v(" 派生缓冲区")]),e._v(" "),a("p",[e._v("派生缓冲区为"),a("code",[e._v("ByteBuf")]),e._v(" 提供了以专门的方式来呈现其内容的视图。这类视图是通过以下方法被创建的：")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("duplicate();")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("slice();")]),e._v("  切片的意思")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("slice(int, int);")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("Unpooled.unmodifiableBuffer(…);")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("order(ByteOrder);")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("readSlice(int);")])])])]),e._v(" "),a("p",[e._v("每个这些方法都将返回一个新的"),a("code",[e._v("ByteBuf")]),e._v(" 实例，"),a("strong",[e._v("它具有自己的读索引、写索引和标记索引")]),e._v("。其内部存储和JDK 的"),a("code",[e._v("ByteBuffer")]),e._v(" 一样也是"),a("strong",[e._v("共享")]),e._v("的。")]),e._v(" "),a("h3",{attrs:{id:"bytebufholder接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytebufholder接口"}},[e._v("#")]),e._v(" ByteBufHolder接口")]),e._v(" "),a("p",[e._v("我们经常发现，除了实际的数据负载之外，我们还需要存储各种属性值。HTTP 响应便是一个很好的例子，除了表示为字节的内容，还包括状态码、"),a("code",[e._v("cookie")]),e._v(" 等。为了处理这种常见的用例，Netty 提供了"),a("code",[e._v("ByteBufHolder")]),e._v("。")]),e._v(" "),a("p",[a("code",[e._v("ByteBufHolder")]),e._v(" 也为Netty 的高级特性提供了支持，如缓冲区池化，其中可以从池中借用ByteBuf，并且在需要时自动释放。"),a("code",[e._v("ByteBufHolder")]),e._v(" 只有几种用于访问底层数据和引用计数的方法。")]),e._v(" "),a("p",[e._v("如果想要实现一个将其有效负载存储在"),a("code",[e._v("ByteBuf")]),e._v(" 中的消息对象，那么"),a("code",[e._v("ByteBufHolder")]),e._v(" 将是个不错的选择。")]),e._v(" "),a("h3",{attrs:{id:"bytebuf分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytebuf分配"}},[e._v("#")]),e._v(" ByteBuf分配")]),e._v(" "),a("h4",{attrs:{id:"池化-bytebufallocator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#池化-bytebufallocator"}},[e._v("#")]),e._v(" 池化-ByteBufAllocator")]),e._v(" "),a("p",[e._v("可以通过Channel（每个都可以有一个不同的"),a("code",[e._v("ByteBufAllocator")]),e._v(" 实例）或者绑定到"),a("code",[e._v("ChannelHandler")]),e._v(" 的"),a("code",[e._v("ChannelHandlerContext")]),e._v(" 获取一个到"),a("code",[e._v("ByteBufAllocator")]),e._v(" 的引用。")]),e._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210727160553639.png",alt:"image-20210727160553639"}})]),e._v(" "),a("h4",{attrs:{id:"unpooled缓冲区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unpooled缓冲区"}},[e._v("#")]),e._v(" Unpooled缓冲区")]),e._v(" "),a("p",[e._v("可能某些情况下，你未能获取一个到ByteBufAllocator 的引用。对于这种情况，Netty 提供了一个简单的称为"),a("code",[e._v("Unpooled")]),e._v(" 的工具类，它提供了静态的辅助方法来创建未池化的ByteBuf实例。")]),e._v(" "),a("p",[a("img",{attrs:{src:"C:%5CUsers%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210727160528004.png",alt:"image-20210727160528004"}})]),e._v(" "),a("p",[e._v("Unpooled 类还使得ByteBuf 同样可用于那些并不需要Netty 的其他组件的非网络项目，使得其能得益于高性能的可扩展的缓冲区API。")]),e._v(" "),a("h4",{attrs:{id:"bytebufutil类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytebufutil类"}},[e._v("#")]),e._v(" ByteBufUtil类")]),e._v(" "),a("p",[e._v("ByteBufUtil 提供了用于操作ByteBuf 的静态的辅助方法。因为这个API 是通用的，"),a("strong",[e._v("并且和池化无关")]),e._v("，所以这些方法已然在分配类的外部实现。")]),e._v(" "),a("h3",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[e._v("#")]),e._v(" 引用计数")]),e._v(" "),a("p",[e._v("引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty 在第4 版中为ByteBuf 和"),a("code",[e._v("ByteBufHolder")]),e._v(" 引入了引用计数技术，它们都实现了interface "),a("code",[e._v("ReferenceCounted")]),e._v("。")]),e._v(" "),a("p",[e._v("引用计数背后的想法并不是特别的复杂；它主要涉及跟踪到某个特定对象的活动引用的数量。一个"),a("code",[e._v("ReferenceCounted")]),e._v(" 实现的实例将通常以活动的引用"),a("strong",[e._v("计数为1 作为开始")]),e._v("。只要引用计数大于0，就能保证对象不会被释放。当活动引用的数量减少到0 时，该实例就会被释放。")]),e._v(" "),a("p",[e._v("注意，虽然释放的确切语义可能是特定于实现的，但是至少已经释放的对象应该不可再用了。引用计数对于池化实现（如"),a("code",[e._v("PooledByteBufAllocator")]),e._v("）来说是至关重要的，它降低了内存分配的开销。")])])}),[],!1,null,null,null);t.default=_.exports}}]);