<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络 | 克林</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="stylesheet" href="https://cdn.clinan.xyz/fontawesome.css">
    <meta name="description" content="生活、技术、摄影">
    
    <link rel="preload" href="/assets/css/0.styles.cc6be2d6.css" as="style"><link rel="preload" href="/assets/js/app.c387313f.js" as="script"><link rel="preload" href="/assets/js/2.07d632c5.js" as="script"><link rel="preload" href="/assets/js/41.53f9abbe.js" as="script"><link rel="prefetch" href="/assets/js/10.7b164219.js"><link rel="prefetch" href="/assets/js/11.f26295a2.js"><link rel="prefetch" href="/assets/js/12.215e9bd1.js"><link rel="prefetch" href="/assets/js/13.916a1030.js"><link rel="prefetch" href="/assets/js/14.6ebe2f7d.js"><link rel="prefetch" href="/assets/js/15.99fd32fe.js"><link rel="prefetch" href="/assets/js/16.a701c814.js"><link rel="prefetch" href="/assets/js/17.031348b7.js"><link rel="prefetch" href="/assets/js/18.149256fc.js"><link rel="prefetch" href="/assets/js/19.e739899c.js"><link rel="prefetch" href="/assets/js/20.dcad2a56.js"><link rel="prefetch" href="/assets/js/21.057b7460.js"><link rel="prefetch" href="/assets/js/22.ce64e41c.js"><link rel="prefetch" href="/assets/js/23.daf19161.js"><link rel="prefetch" href="/assets/js/24.749d98a7.js"><link rel="prefetch" href="/assets/js/25.3a6551a2.js"><link rel="prefetch" href="/assets/js/26.67d5bf4f.js"><link rel="prefetch" href="/assets/js/27.d11f18f3.js"><link rel="prefetch" href="/assets/js/28.98119994.js"><link rel="prefetch" href="/assets/js/29.f81591b4.js"><link rel="prefetch" href="/assets/js/3.925378c0.js"><link rel="prefetch" href="/assets/js/30.3d37f95f.js"><link rel="prefetch" href="/assets/js/31.6ddfa063.js"><link rel="prefetch" href="/assets/js/32.6782db54.js"><link rel="prefetch" href="/assets/js/33.c32aacff.js"><link rel="prefetch" href="/assets/js/34.0d6b18cf.js"><link rel="prefetch" href="/assets/js/35.90fa8707.js"><link rel="prefetch" href="/assets/js/36.b75b717d.js"><link rel="prefetch" href="/assets/js/37.d5574023.js"><link rel="prefetch" href="/assets/js/38.9666c5d9.js"><link rel="prefetch" href="/assets/js/39.be9b8db9.js"><link rel="prefetch" href="/assets/js/4.c338ef74.js"><link rel="prefetch" href="/assets/js/40.0496212f.js"><link rel="prefetch" href="/assets/js/42.48e3621f.js"><link rel="prefetch" href="/assets/js/43.ded57d48.js"><link rel="prefetch" href="/assets/js/44.027366a5.js"><link rel="prefetch" href="/assets/js/45.270bebde.js"><link rel="prefetch" href="/assets/js/46.5cb35b21.js"><link rel="prefetch" href="/assets/js/47.9df7131a.js"><link rel="prefetch" href="/assets/js/48.58499a70.js"><link rel="prefetch" href="/assets/js/49.ca61ec46.js"><link rel="prefetch" href="/assets/js/5.ee90145e.js"><link rel="prefetch" href="/assets/js/50.237e199e.js"><link rel="prefetch" href="/assets/js/51.f571cf97.js"><link rel="prefetch" href="/assets/js/52.57d87431.js"><link rel="prefetch" href="/assets/js/53.163cbc01.js"><link rel="prefetch" href="/assets/js/54.22559499.js"><link rel="prefetch" href="/assets/js/55.7620fc70.js"><link rel="prefetch" href="/assets/js/56.dd45b171.js"><link rel="prefetch" href="/assets/js/57.1edff986.js"><link rel="prefetch" href="/assets/js/58.6ddb12e0.js"><link rel="prefetch" href="/assets/js/59.8243df7f.js"><link rel="prefetch" href="/assets/js/6.049d604b.js"><link rel="prefetch" href="/assets/js/60.665f6dc9.js"><link rel="prefetch" href="/assets/js/61.13f75167.js"><link rel="prefetch" href="/assets/js/62.cf46bf76.js"><link rel="prefetch" href="/assets/js/63.0bbbaeeb.js"><link rel="prefetch" href="/assets/js/64.d8daf8e4.js"><link rel="prefetch" href="/assets/js/65.5075cbc9.js"><link rel="prefetch" href="/assets/js/66.dfb3c850.js"><link rel="prefetch" href="/assets/js/67.c9920c80.js"><link rel="prefetch" href="/assets/js/68.7ba3806a.js"><link rel="prefetch" href="/assets/js/69.4df1b72c.js"><link rel="prefetch" href="/assets/js/7.61da790d.js"><link rel="prefetch" href="/assets/js/70.f44691e5.js"><link rel="prefetch" href="/assets/js/71.79e7b907.js"><link rel="prefetch" href="/assets/js/72.76c7a030.js"><link rel="prefetch" href="/assets/js/73.15d46a8c.js"><link rel="prefetch" href="/assets/js/74.7da23b80.js"><link rel="prefetch" href="/assets/js/75.2ab83637.js"><link rel="prefetch" href="/assets/js/76.fb7ef46f.js"><link rel="prefetch" href="/assets/js/77.c462d8d1.js"><link rel="prefetch" href="/assets/js/78.378764eb.js"><link rel="prefetch" href="/assets/js/8.f851a47e.js"><link rel="prefetch" href="/assets/js/9.9d6d487d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cc6be2d6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.clinan.xyz/mini_logo.png" alt="克林" class="logo"> <span class="site-name can-hide">克林</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/modules/literature/" class="nav-link">现代文学</a></div><div class="nav-item"><a href="/modules/technology/" class="nav-link router-link-active">杂技奇谭</a></div><div class="nav-item"><a href="/modules/life/" class="nav-link">吃草日常</a></div><div class="nav-item"><a href="/modules/photography/" class="nav-link">无后期摄影</a></div> <a href="https://github.com/clinan/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/modules/literature/" class="nav-link">现代文学</a></div><div class="nav-item"><a href="/modules/technology/" class="nav-link router-link-active">杂技奇谭</a></div><div class="nav-item"><a href="/modules/life/" class="nav-link">吃草日常</a></div><div class="nav-item"><a href="/modules/photography/" class="nav-link">无后期摄影</a></div> <a href="https://github.com/clinan/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/modules/technology/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>架构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>DB</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringCloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux(Debian)</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础知识</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/modules/technology/base/algorithm.html" class="sidebar-link">算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/base/algorithm.html#计算器问题" class="sidebar-link">计算器问题</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/algorithm.html#排序" class="sidebar-link">排序</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/algorithm.html#数据结构" class="sidebar-link">数据结构</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/algorithm.html#高级设计和分析技术" class="sidebar-link">高级设计和分析技术</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/algorithm.html#图" class="sidebar-link">图</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/algorithm.html#双指针" class="sidebar-link">双指针</a></li></ul></li><li><a href="/modules/technology/base/tcpip.html" aria-current="page" class="active sidebar-link">计算机网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#分层" class="sidebar-link">分层</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#可靠的tcp-不可靠的udp-不可靠的ip" class="sidebar-link">可靠的TCP 不可靠的UDP 不可靠的IP</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#单工-半双工-全双工" class="sidebar-link">单工 半双工 全双工</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#封装" class="sidebar-link">封装</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#以太网" class="sidebar-link">以太网</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#环回接口" class="sidebar-link">环回接口</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#mtu-最大传输单元" class="sidebar-link">MTU 最大传输单元</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#ip" class="sidebar-link">IP</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#arp" class="sidebar-link">ARP</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#tcp头部" class="sidebar-link">TCP头部</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#tcp连接与关闭" class="sidebar-link">TCP连接与关闭</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#超时与重传" class="sidebar-link">超时与重传</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#数据流" class="sidebar-link">数据流</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#流量控制和窗口滑动" class="sidebar-link">流量控制和窗口滑动</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#拥塞控制" class="sidebar-link">拥塞控制</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#保活机制" class="sidebar-link">保活机制</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#方法" class="sidebar-link">方法</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/tcpip.html#header" class="sidebar-link">Header</a></li></ul></li><li><a href="/modules/technology/base/binary.html" class="sidebar-link">计算机组成原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/base/binary.html#二进制整数及其运算" class="sidebar-link">二进制整数及其运算</a></li></ul></li><li><a href="/modules/technology/base/pattern.html" class="sidebar-link">设计模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#策略模式" class="sidebar-link">策略模式</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#观察者模式" class="sidebar-link">观察者模式</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#装饰者模式" class="sidebar-link">装饰者模式</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#工厂模式" class="sidebar-link">工厂模式</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#单例模式" class="sidebar-link">单例模式</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#命令模式" class="sidebar-link">命令模式</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#模板方法" class="sidebar-link">模板方法</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#状态模式" class="sidebar-link">状态模式</a></li><li class="sidebar-sub-header"><a href="/modules/technology/base/pattern.html#外观-适配器-代理模式" class="sidebar-link">外观，适配器，代理模式</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="计算机网络"><a href="#计算机网络" class="header-anchor">#</a> 计算机网络</h1> <h2 id="分层"><a href="#分层" class="header-anchor">#</a> 分层</h2> <ol><li>应用层：处理特定的应用程序细节</li> <li>传输层：为两台主机上的应用程序提供端到端的通讯</li> <li>网络层：处理分组在网络中的活动，例如分组选路</li> <li>链路层：处理与电缆（或其他让任何传输媒介）的物理接口细节</li></ol> <table><thead><tr><th>OSI</th> <th>TCP/IP</th> <th>对应概念</th></tr></thead> <tbody><tr><td>应用层</td> <td>应用层</td> <td>HTTP,FTP,SMTP</td></tr> <tr><td>表示层</td> <td>应用层</td> <td>telnet, Gopher</td></tr> <tr><td>会话层</td> <td>应用层</td> <td>SMTP,DNS</td></tr> <tr><td>传输层</td> <td>传输层</td> <td>TCP, UDP</td></tr> <tr><td>网络层</td> <td>网络层</td> <td>IP, ARP,RARP,ICMP</td></tr> <tr><td>链路层</td> <td>链路层</td> <td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td></tr> <tr><td>物理层</td> <td>链路层</td> <td>IEEE 802.1A, IEEE 802.2到IEEE 802.11</td></tr></tbody></table> <ul><li>ICMP 协议</li> <li>ping是一个应用程序，调用了ICMP协议</li></ul> <p><img src="https://cdn.clinan.xyz/net.png" alt=""></p> <p><img src="https://cdn.clinan.xyz/fenceng.png" alt=""></p> <h2 id="可靠的tcp-不可靠的udp-不可靠的ip"><a href="#可靠的tcp-不可靠的udp-不可靠的ip" class="header-anchor">#</a> 可靠的TCP 不可靠的UDP 不可靠的IP</h2> <ol><li>可靠的TCP通过不可靠的IP传输数据</li> <li>不可靠的UDP通过不可靠的IP传输数据</li></ol> <h2 id="单工-半双工-全双工"><a href="#单工-半双工-全双工" class="header-anchor">#</a> 单工 半双工 全双工</h2> <ul><li>单工，传输和接收要建立两个连接会话，且是不同的端口号</li> <li>半双工，传输和接收只需要建立一个会话（长连接），但是不能同时发送和接收。
<ul><li><strong>http1.1</strong>：建立长连接，多路复用，可先后发送多个http请求，不用等待回复，但是回复得按顺序一个一个回复</li></ul></li> <li>全双工，传输和接收只需要建立一个会话，能同时发送和接收
<ul><li><strong>http2.0</strong>： 一个消息发送后不用等待接受,第二个消息可以直接发送</li> <li>socket：不可靠</li></ul></li></ul> <h2 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h2> <p><img src="https://cdn.clinan.xyz/data-packet.png" alt=""> <img src="https://cdn.clinan.xyz/demultiplexing.png" alt=""></p> <ul><li>以太网数据帧的物理特性是其长度必须在46~1500字节之间</li> <li>以太网的帧首部也有一个16bit的帧类型域（IP,ARP,RARP）</li> <li>IP在首部中存入一个长度为8bit的数值，称为协议域（ICMP,IGMP,TCP,UDP,ESP,GRE）</li> <li>TCP和UDP都用一个16bit的端口号表示不同的应用程序（FTP, telnet, http）（所以端口的范围是0~2^16-1，其中1~1023是保留端口号）</li></ul> <h2 id="以太网"><a href="#以太网" class="header-anchor">#</a> 以太网</h2> <p><img src="https://cdn.clinan.xyz/ethernet.png" alt=""></p> <h2 id="环回接口"><a href="#环回接口" class="header-anchor">#</a> 环回接口</h2> <p>127.0.0.1环回地址</p> <p><img src="https://cdn.clinan.xyz/loopback.png" alt=""></p> <h2 id="mtu-最大传输单元"><a href="#mtu-最大传输单元" class="header-anchor">#</a> <code>MTU</code> 最大传输单元</h2> <p>链路层网络中（例如以太网）中，携带高层协议的大小是有限制的。以太网有效负荷的字节数通常被限制为1500，<code>PPP</code>通常也采用相同大小以保持与以太网兼容。链路层的这种性质被称为<strong>最大传输单元<code>MTU</code></strong></p> <h2 id="ip"><a href="#ip" class="header-anchor">#</a> IP</h2> <p><img src="https://cdn.clinan.xyz/IP-protocol.png" alt=""></p> <ul><li>版本号 4bit</li> <li>首部长度4bit, 最大值为15，每增加1，则首部长度增加4bit, 所以IPv4最多支持15*4=60bit的头部长度</li></ul> <h2 id="arp"><a href="#arp" class="header-anchor">#</a> ARP</h2> <p><img src="https://cdn.clinan.xyz/ARP.png" alt=""></p> <ul><li>路由表</li></ul> <h2 id="tcp头部"><a href="#tcp头部" class="header-anchor">#</a> TCP头部</h2> <p><img src="https://cdn.clinan.xyz/tcp.png" alt=""></p> <ul><li><p>32位序号，<code>SYN</code>，<code>FIN</code>都会消耗序号，<code>ACK</code>不占用序号，因为<code>ACK</code>也是首部的一部分，一旦一个连接建立，<code>ACK</code>总是被设置为1</p></li> <li><p>TCP提供一直面向连接的，可靠的字节流服务</p></li> <li><p>在一个TCP连接中，仅有两方进行彼此通信。</p></li> <li><p>能够提供流量控制（窗口大小）</p></li> <li><p>一个IP和一个端口也称为插口（<code>socket</code>），后来它也表示伯克利版的编程接口。</p></li> <li><p>若ACK=N，则表明：到序号N-1为止的所有数据都已正确收到</p></li> <li><p>接收机器缓存有限，窗口字段明确指出了现在允许对方发送的数据量，窗口值是经常在动态变化着的</p></li> <li><p>检验和，检验和数据检验的范围包括首部和数据这两部分</p></li></ul> <table style="text-align:center;"><tr><th colspan="32">TCP头部，最长60字节，当前一行32bit  </th></tr> <tr><td colspan="16">源（source）端口号0-65535  </td> <td colspan="16">目标（target）端口号0-65535  </td></tr> <tr><td colspan="32">序列号(Sequence Number)</td></tr> <tr><td colspan="32">ACK(acknowlegde) sequence number确认序列号</td></tr> <tr><td colspan="4">头部长度4bit</td> <td colspan="4">4bit保留</td> <td colspan="1">CWR</td> <td colspan="1">ECE</td> <td colspan="1">URG</td> <td colspan="1">ACK</td> <td colspan="1">PSH</td> <td colspan="1">RST</td> <td colspan="1">SYN</td> <td colspan="1">FIN</td> <td colspan="16">窗口大小 16bit，可以通过选项加大</td></tr> <tr><td colspan="16">校验和 </td> <td colspan="16">紧急指针 </td></tr> <tr><td colspan="32">选项</td></tr></table> <h3 id="psh标志位"><a href="#psh标志位" class="header-anchor">#</a> PSH标志位</h3> <p>在传输大数据的时候，在TCP中会分块传输。如果遇到设置了PSH位的数据段，则将当前数据段中的数据和缓存中的数据都提交给应用层，并清空缓存。而不用继续等待或判断后续是否还有数据传输过来。</p> <h3 id="选项"><a href="#选项" class="header-anchor">#</a> 选项</h3> <p><code>MSS</code>（maximum segment size）：最大报文段</p> <p>SACK： 选择<code>ACK</code></p> <p><code>Scale_Window</code>(SW)：窗口缩放支持</p> <h2 id="tcp连接与关闭"><a href="#tcp连接与关闭" class="header-anchor">#</a> TCP连接与关闭</h2> <h3 id="连接-三次握手"><a href="#连接-三次握手" class="header-anchor">#</a> 连接 三次握手</h3> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><h3 id="关闭-四次握手"><a href="#关闭-四次握手" class="header-anchor">#</a> 关闭 四次握手</h3> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><p>一些说明</p> <ul><li><code>FIN_WAIT_1</code>，<code>FIN_WAIT_2</code>，<code>TIME_WAIT</code>也被称为主动关闭。表示当本地应用程序发起一个关闭请求时会进入的状态集合。</li> <li><code>CLOSE_WAIT</code>，<code>LAST_ACK</code>被称为被动关闭。这些状态与等待一个FIN报文段并进行关闭相关。</li></ul> <h3 id="半关闭"><a href="#半关闭" class="header-anchor">#</a> 半关闭</h3> <p>当客户端发送了FIN之后，处于<code>FIN_WAIT_1</code>，<code>FIN_WAIT_2</code>的状态都是半关闭状态。</p> <h3 id="time-wait"><a href="#time-wait" class="header-anchor">#</a> TIME_WAIT</h3> <p>TIME_WAIT是客户端发完确认关闭<code>ACK</code>之后，为避免还停留在网络中的数据段的影响，等待两倍的最大段生存时间（maximum segment Lifetime，<code>MSL</code>）。</p> <p>在<code>Linux</code>下可以通过<code>cat /etc/sysctl.conf</code>，查看<code>net.ipv4.tcp_fin_timeout</code> 默认是60，单位为秒</p> <p><strong>为什么是两倍的段最大生存时间（<code>2MSL</code>）？</strong></p> <p>因为被关闭方可能会超时重传FIN，直到收到最终<code>ACK</code>。但是下一刻就收到主动关闭方的<code>ACK</code>，从发出<code>LastACK</code>的发出到接收到重传的FIN。客户端最多可以经历<code>2MSL</code>的时间。</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><p><strong>重点</strong></p> <p>另外一个影响<code>2MSL</code>的因素是当TCP处于<code>TIME_WAIT</code>状态时，通信双方将该连接（<code>client ip+port, server ip+port</code>）标志为不可重新使用。只有<code>2MSL</code>结束之后，才能被重新使用。</p> <p>在TCP头部中，是没有记录<code>IP</code>的，所以在主动关闭方来说，目标端口固定的情况下，自身随机端口，是有可能用完65535个端口的。</p> <h4 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h4> <p>在Linux中调整<code>MSL</code>的时间为<code>30s</code>，<code>Http</code>使用<code>Http1.1</code>，使用<code>KeepAlive</code>，TCP采用保活机制。</p> <h3 id="close-wait"><a href="#close-wait" class="header-anchor">#</a> CLOSE_WAIT</h3> <p>如果使用<code>HttpClient</code>不关闭<code>InputStream</code>，也会导致占用，而且情况比<code>TIME_WAIT</code>更严重，因为它不会释放TCP连接。如果没有配置<code>TCP</code>保活机制，则服务器会一直处于<code>CLOSE_WAIT</code>状态。</p> <h4 id="解决方案-2"><a href="#解决方案-2" class="header-anchor">#</a> 解决方案</h4> <p>查看代码，关注<code>HttpClient</code>的使用，<a href="https://blog.csdn.net/shootyou/article/details/6615051" target="_blank" rel="noopener noreferrer">相关博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="close-wait和time-wait查看"><a href="#close-wait和time-wait查看" class="header-anchor">#</a> CLOSE_WAIT和TIME_WAIT查看</h3> <p><code>netstat -n | awk *'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'*</code></p> <h3 id="静默时间"><a href="#静默时间" class="header-anchor">#</a> 静默时间</h3> <p>在三次握手之前，静默一个<code>MSL</code>。现在一般操作系统都不会再实现了。</p> <h3 id="重置报文段"><a href="#重置报文段" class="header-anchor">#</a> 重置报文段</h3> <h4 id="对不存在的端口进行连接请求"><a href="#对不存在的端口进行连接请求" class="header-anchor">#</a> 对不存在的端口进行连接请求</h4> <p>服务器会返回<code>ACK+RST, ACK=ISN(c)+1,Seq=0</code>的消息。这个过程会有重试</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><h4 id="终止一条连接"><a href="#终止一条连接" class="header-anchor">#</a> 终止一条连接</h4> <p>正常客户端发送<code>FIN</code>是一个正常的关闭连接的方法。也被成为<strong>有序释放</strong></p> <p>此外，也可以通过发送<strong>重置报文</strong>替代FIN来终止一条连接，也称为<strong>终止释放</strong></p> <h2 id="超时与重传"><a href="#超时与重传" class="header-anchor">#</a> 超时与重传</h2> <ul><li><p>每次重传间隔时间加倍称为 <strong>二进制指数退避</strong></p></li> <li><p>TCP拥有两个阈值来决定如何重传同一个报文段。</p> <ul><li>R1表示TCP向IP层传递“消极建议”前，愿意尝试重传的次数</li> <li>R2（大于R1）指示TCP放弃当前连接的时机。</li> <li>R1和R2应分别设为3次重传和100秒</li> <li>Linux中<code>R1=net.ipv4.tcp_retries1</code>默认值为3次，<code>R2=net.ipv4.tcp_retries2</code>默认值为15次，约为13~30分钟</li> <li>对于SYN报文
<ul><li><code>net.ipv4.tcp_syn_retries</code>和<code>net.ipv4.tcp_synack_retries</code>限定重传次数，默认值为5，约180s</li></ul></li></ul></li></ul> <h3 id="设置重传超时时间rto"><a href="#设置重传超时时间rto" class="header-anchor">#</a> 设置重传超时时间RTO</h3> <p>通过对<code>RTT</code>测量采样计算<code>RTO</code>。</p> <p>这部分太难了，一般都不会问。</p> <h3 id="基于的计时器的重传"><a href="#基于的计时器的重传" class="header-anchor">#</a> 基于的计时器的重传</h3> <p>在重传第一次后，没有收到确认，需要等待更久的时间再发送第二次重传，称为<strong>退避值</strong></p> <p>当一报文出现多次重传时，<code>RTO</code>值（暂时地）乘上<code>γ</code>来形成新的退避值</p> <section><div class="vuepress-eqn"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>γ</mi><mi>R</mi><mi>T</mi><mi>O</mi></mrow><annotation encoding="application/x-tex">
RTO=γRTO
</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span></span></div></section><p>通常情况下，<code>γ</code>=1，随着多次重传，<code>γ</code>加倍指数增长。通常情况下不能超过最大退避因子。（<code>Linux</code>确保<code>RTO</code>设置不能超过<code>TCP_RTO_MAX</code>，默认值为120s），一旦收到对于的<code>ACK</code>，<code>γ</code>重置为1</p> <h3 id="快速重传"><a href="#快速重传" class="header-anchor">#</a> 快速重传</h3> <p>基于接收端的反馈信息来引发重传，而非重传计时器的超时。</p> <p>具体描述如下：</p> <p>TCP发送端在观测到至少<code>dupthresh</code>(称为重复<code>ACK</code>阈值)个重复<code>ACK</code>后，就重传可能丢失的数据，而不必等到重传计时器超时。</p> <p>可以使用SACK进行快速重传</p> <h3 id="带选择确认的重传sack"><a href="#带选择确认的重传sack" class="header-anchor">#</a> 带选择确认的重传SACK</h3> <ul><li><strong><code>SACK</code>和普通的<code>ACK</code>有时会丢失，并且其中不包含数据（SYN或FIN也不被置位）就不会被重传。</strong></li></ul> <h4 id="数据接收端行为"><a href="#数据接收端行为" class="header-anchor">#</a> 数据接收端行为</h4> <p>接收端在TCP连接建立期间，收到<code>SACK</code>许可选项即可生成<code>SACK</code>。通常来说，当缓存中存在失序数据时，接收端就可生成<code>SACK</code>.</p> <p>第一个<code>SACK</code>块内包含的是最近接收到的报文段的序列号范围。其余<code>SACK</code>块包含的内容也按照接收的先后依次排序。</p> <p>最新的要发送的块，除了包含数据内容外，还会有最新的<code>SACK</code>的块，也<strong>重复</strong>之前的<code>SACK</code>块。所以一个<code>SACK</code>选项会包含多个<code>SACK</code>块。<strong>目的是为防止<code>SACK</code>丢失提供一些备份</strong>（因为上面说了<code>SACK</code>和<code>ACK</code>不会重传，丢了就丢了）</p> <h4 id="数据发送端行为"><a href="#数据发送端行为" class="header-anchor">#</a> 数据发送端行为</h4> <p>当数据发送端执行重传时，通常是由于其收到了<code>SACK</code>或重复<code>ACK</code>，它可以选择重新发送新数据或重传旧数据。<code>SACK</code>提供的接收端序列号范围，因此发送端可根据此推断需要重传的空缺数据。</p> <p>由于快速重传机制，所以需要观测<code>dupthresh</code>个<code>SACK</code>之后，才会进行重传。</p> <h2 id="数据流"><a href="#数据流" class="header-anchor">#</a> 数据流</h2> <h3 id="延时确认-delayed-ack"><a href="#延时确认-delayed-ack" class="header-anchor">#</a> 延时确认（<code>delayed-ACK</code>）</h3> <p>延时ACK针对的是接收端</p> <p>TCP并不对每个到来的数据包都返回ACK，利用TCP的累积ACK字段就能实现该功能。累积确认可以允许延迟一段时间发送ACK，以便将ACK和向相同方向上需要传的数据结合发送。这种传输方式经常用于批量数据传输。</p> <p>作用：会减少ACK传输条目，可以一定程度减轻网络负载。</p> <p>对于批量数据传输通常为2：1的比例。<code>Linux</code>使用一种动态调节算法，可以在每个报文段返回一个ACK与传统延时ACK模式间相互切换。</p> <blockquote><p>有论文指出，TCP实现ACK延迟的时延应小于500ms。实践中时延最大取<strong>200ms</strong></p></blockquote> <h3 id="nagle算法-俗称粘包"><a href="#nagle算法-俗称粘包" class="header-anchor">#</a> <code>Nagle</code>算法（俗称粘包）</h3> <p><code>Nagle</code>算法针对数据发送端。</p> <p>当一个TCP连接中有在传数据（即那些已发送但还未经确认的数据），小的报文段（长度小于<code>SMSS</code>, Sender maximum segment size,  发送方最大段大小）就不能被发送，直到所有在传的数据都收到ACK。<strong>并且在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。</strong></p> <p>在<code>Nagle</code>算法超时后，也会直接发送小的数据包</p> <p>作用：可以减少发送方包的数目，疯狂发送小的数据包。同时也会减少接收方的ACK。</p> <p>缺点：增大了传输时延。会导致传输不及时。</p> <h3 id="延时ack-nagle算法的结合使用"><a href="#延时ack-nagle算法的结合使用" class="header-anchor">#</a> 延时ACK+Nagle算法的结合使用</h3> <p>会导致逻辑意义上的死锁，但是延时<code>ACK</code>和<code>Nagle</code>算法都实现了超时机制。不会发生真正的死锁。</p> <p>但是会导致网络有了更大的延迟。</p> <h2 id="流量控制和窗口滑动"><a href="#流量控制和窗口滑动" class="header-anchor">#</a> 流量控制和窗口滑动</h2> <p>流量控制因为当数据发送方的发送速率超过接收方的处理速度。会导致很多没有必要的重传，导致网络拥塞。</p> <p>窗口滑动是流量控制的一种方案。</p> <p>TCP头部中的窗口大小最大为65535，<strong>单位为字节，而不是段</strong>。<strong>此外MSS的单位也是字节</strong></p> <h3 id="tcp的窗口控制"><a href="#tcp的窗口控制" class="header-anchor">#</a> TCP的窗口控制</h3> <h4 id="发送窗口"><a href="#发送窗口" class="header-anchor">#</a> 发送窗口</h4> <table><tr><td align="center" colspan="3"></td> <td align="center" colspan="5">提供窗口（SND.WND）</td> <td align="center" colspan="3"></td></tr> <tr><td align="center" colspan="1">...</td> <td align="center" colspan="1">5</td> <td align="center" colspan="1">6</td> <td align="center" colspan="1">7</td> <td align="center" colspan="1">8</td> <td align="center" colspan="1">9</td> <td align="center" colspan="1">10</td> <td align="center" colspan="1">11</td> <td align="center" colspan="1">12</td> <td align="center" colspan="1">13</td> <td align="center" colspan="1">...</td></tr> <tr><td align="center" colspan="3">已发送并已确认</td> <td align="center" colspan="3">已发送但未确认</td> <td align="center" colspan="2">即将发送（可用窗口）</td> <td align="center" colspan="3">直到窗口移动前都不能发送</td></tr> <tr><td align="center" colspan="2"></td> <td align="center" colspan="2">左边界（SND.UNA）</td> <td align="center" colspan="1"></td> <td align="center" colspan="2">SND.NXT</td> <td align="center" colspan="2">右边界（SND.UNA+SND.WND）</td> <td colspan="2"></td></tr></table> <h4 id="接收窗口"><a href="#接收窗口" class="header-anchor">#</a> 接收窗口</h4> <table><tr><td align="center" colspan="3"></td> <td align="center" colspan="5">接收窗口（REV.WND）</td> <td align="center" colspan="3"></td></tr> <tr><td align="center" colspan="1">...</td> <td align="center" colspan="1">5</td> <td align="center" colspan="1">6</td> <td align="center" colspan="1">7</td> <td align="center" colspan="1">8</td> <td align="center" colspan="1">9</td> <td align="center" colspan="1">10</td> <td align="center" colspan="1">11</td> <td align="center" colspan="1">12</td> <td align="center" colspan="1">13</td> <td align="center" colspan="1">...</td></tr> <tr><td align="center" colspan="3">已接收并确认</td> <td align="center" colspan="5">接收后将会保存</td> <td align="center" colspan="3">不能接收</td></tr> <tr><td align="center" colspan="2"></td> <td align="center" colspan="2">左边界（REV.NXT）</td> <td align="center" colspan="3"></td> <td align="center" colspan="2">右边界（REV.NXT+REV.WND）</td> <td colspan="2"></td></tr></table>
传统的TCP的累积ACK结构，只有当到达数据序列号等于左边界时，数据才不会被丢失，窗口才能向前滑动。
<p>对于选择确认ACK，使用<code>SACK</code>选项，窗口内的报文段也可以被接收确认，但只有在接收到等于左边界的序列号数据时，窗口才能前移。</p> <h4 id="零窗口与tcp持续计时器"><a href="#零窗口与tcp持续计时器" class="header-anchor">#</a> 零窗口与TCP持续计时器</h4> <p>当窗口值为0时，可以有效阻止发送端继续发送，直到窗口大小恢复为非零值。当接收端重新获得可用窗口时，会给发送端传输一个<strong>窗口更新</strong>（window update），告知其可继续发送数据。这样的窗口更新都不包含数据（所以也不会超时重传），不能保证可靠性。</p> <p>如果<code>window update</code>的<code>ACK</code>丢失，通信双方会一直处于等待状态。</p> <p><strong>解决方案：</strong></p> <p>发送端会采用一个<strong>持续计时器</strong>间歇性地查询接收端，看其窗口是否已增长。具体的，持续计时器会触发<strong>窗口探测</strong>（window probe）的传输，强烈要求接收端返回<code>ACK</code>（其中包含窗口大小字段）。</p> <p><code>window prove</code>包含一个字节的数据，这样可以超时重传。因此可以避免窗口丢失的死锁。</p> <h2 id="拥塞控制"><a href="#拥塞控制" class="header-anchor">#</a> 拥塞控制</h2> <p>拥塞控制在网络中有很大的作用，当所有主机都以自己最大的能力持续的发送数据段，在网络环境很差的情况下，数据段又一直不能被接收方接收到（发送方收不到<code>ACK</code>），发送方就会超时重传。如果一直接收不到ACK就会一直超时重传，最终会导致阻塞在网络中的数据越来越多。最后将整个网络通信堵塞。</p> <p>但是另一方面又想最大限度的使用网络，然而网络通信的复杂性导致无法了解这个最大限度的值，并且这个值是动态的，每次网络波动之后，都需要重新去寻找这个阈值，所以只能一点点的逼近，一旦超过，就立即返回之前的数据发送大小。</p> <h3 id="减缓tcp发送"><a href="#减缓tcp发送" class="header-anchor">#</a> 减缓TCP发送</h3> <p>可用窗口<code>W=min(cwnd, awnd)</code>，<code>cwnd</code>为拥塞端口大小，<code>awnd</code>为接收方窗口大小。一般来说，计算机发送和接收端都不能精确的计算<code>cwnd</code>的值。并且这个值是在动态变化的。</p> <h3 id="慢启动"><a href="#慢启动" class="header-anchor">#</a> 慢启动</h3> <p>在传输初始的时候，由于网络传输能力未知。需要缓慢探测可用传输资源，防止短时间内大量数据注入导致拥塞。</p> <h4 id="场景"><a href="#场景" class="header-anchor">#</a> 场景</h4> <ul><li>创建新的TCP连接时</li> <li>检测到由重传超时（<code>RTO</code>）导致的丢包时，需要执行慢启动。</li> <li>TCP发送端长时间空闲状态也可能调用慢启动算法。</li></ul> <h4 id="目的"><a href="#目的" class="header-anchor">#</a> 目的</h4> <p>在用拥塞避免的方法探寻更多可用带宽接近的<code>cwnd</code>值，以帮助TCP建立<code>ACK</code>时钟。</p> <h4 id="创建连接时的慢启动"><a href="#创建连接时的慢启动" class="header-anchor">#</a> 创建连接时的慢启动</h4> <p>在创建新连接时执行慢启动，直至有丢包时，执行拥塞避免算法（下一小节）进入稳定状态。</p> <p>具体的：</p> <ol><li>TCP以发送一定数量的数据段开始慢启动（SYN交换之后），成为<strong>初始窗口（<code>IW</code>）</strong>，<code>IW</code>的初始值设为1<code>SMSS</code>（发送方的最大段大小）。</li> <li>在接收到一个数据段的<code>ACK</code>之后，通常<code>cwnd</code>会增加到2，接着发送2个数据段。</li> <li>如果对应的接收到新的<code>ACK</code>，<code>cwnd</code>会由2变成4、然后到8。呈<strong>指数</strong>级上升。</li> <li>呈指数上升之后，<code>cwnd</code>会非常大，一旦发生丢包，<code>cwnd</code>将立即减为原来的一半，即上一次没有发生丢包的<code>cwnd</code>。<strong>这就是慢启动转为拥塞避免阶段的转折点</strong>。此时的<code>cwnd</code>也就是慢启动的<strong>阈值</strong>（<code>ssthresh</code>）</li></ol> <h3 id="拥塞避免"><a href="#拥塞避免" class="header-anchor">#</a> 拥塞避免</h3> <p>在通过慢启动确认慢启动阈值之后，<code>cwnd</code>的增长将会转为<strong>线性增长</strong>。可以逐步尽可能的使用更多的网络资源。也避免大量的数据堵塞整个传输网络。</p> <p>其中如果要是开启了延时<code>ACK</code>，则增长速率会比正常的线性增长还要慢一些。</p> <h3 id="快速恢复"><a href="#快速恢复" class="header-anchor">#</a> 快速恢复</h3> <p>BSD Tahoe版本的TCP，在检测到丢包之后，无论是超时还是快速重传，都会重新开始进入慢启动状态。在有丢包的情况发生时，<code>Tahoe</code>简单地将<code>cwnd</code>减为初始值（<code>1SMSS</code>），以达到慢启动的目的。直到找到新的阈值<code>ssthresh</code></p> <p>导致宽带利用率低下。</p> <p>在BSD Reno版中，在遇到因为快速重传（发送方收到重复的<code>ACK</code>）时，<code>cwnd</code>被设置为上一个<code>ssthresh</code>。而无需重新慢启动。但是在大多数的TCP版本中，超时导致的慢启动问题还是存在。</p> <h3 id="newreno"><a href="#newreno" class="header-anchor">#</a> <code>NewReno</code></h3> <p>快速恢复带来了一个新的问题，当一个传输窗口中出现多个数据包丢失时，一旦其中一个包重传成功，发送方就会接收到一个成功的 <code>ACK</code>，这样快速恢复中<code>cwnd</code>窗口的暂时膨胀就会停止，而事实上丢失的其他数据包未完成重传。导致出现这种情况的<code>ACK</code>成为局部<code>ACK</code>（<code>partial ACK</code>）。Reno算法在接收到局部<code>ACK</code>后就停止拥塞窗口膨胀阶段，并将其减小到特定值。这会严重的浪费网络性能。</p> <p><code>NewReno</code>算法提出，记录上一个数据传输窗口的最高序列号，仅当接收到序列号不小于恢复点的<code>ACK</code>才停止快速恢复阶段。这样TCP发送方每接收一个<code>ACK</code>后就能继续发送一个新数据段，从而减少重传超时的发生。</p> <h2 id="保活机制"><a href="#保活机制" class="header-anchor">#</a> 保活机制</h2> <p>三个变量</p> <ol><li>保活时间：<code>net.ipv4tcp_keepalive_time</code>= 7200s (2h)</li> <li>保活时间间隔：<code>net.ipv4.tcp_keepalive_intvl</code>= 75s</li> <li>保活探测次数：<code>net.ipv4.tcp_keepalive_probes</code>= 9</li></ol> <h1 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h1> <h2 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h2> <h3 id="put"><a href="#put" class="header-anchor">#</a> PUT</h3> <p>目的是让服务器用请求的主体部分来创建一个由请求的URL命名的新文档。如果那个URL已经存在的话，就用这个主体替代。</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT /files/images/upload.png
<span class="token header-name keyword">Host:</span> www.xxx.com

... 文件流
</code></pre></div><h3 id="head"><a href="#head" class="header-anchor">#</a> HEAD</h3> <p>不返回数据，只返回头部。这就允许在不获取实际数据的情况下，了解数据的情况，并且也可以对返回体头部进行校验</p> <p>作用如下：</p> <ul><li>在不获取资源的情况下了解资源</li> <li>通过查看状态码，了解某个对象是否存在</li> <li>通过查看首部，测试资源是否被修改</li></ul> <h3 id="post"><a href="#post" class="header-anchor">#</a> POST</h3> <p>通常是表单的传输</p> <h3 id="trace"><a href="#trace" class="header-anchor">#</a> TRACE</h3> <p>客户端发出一个请求后，可能会经过防火墙，代理，网关或一些其他应用程序。</p> <p>每个中间节点都有可能修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发给服务器时，看看它变成了什么样子。</p> <p>TRACE会在目的服务器发起一个环回诊断，最后的服务器会弹回一条TRACE相应，并在响应主体中携带它收到的原始请求报文。</p> <h3 id="options"><a href="#options" class="header-anchor">#</a> OPTIONS</h3> <p>请求Web服务器告知其支持的各种功能。如跨域。也包含各种支持的方法</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">access-control-allow-origin:</span>	*
<span class="token header-name keyword">allow:</span>	GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS
<span class="token header-name keyword">cache-control:</span>	no-cache, no-store, max-age=0, must-revalidate
<span class="token header-name keyword">date:</span>	Thu, 06 May 2021 03:11:11 GMT
<span class="token header-name keyword">expires:</span>	0
<span class="token header-name keyword">pragma:</span>	no-cache
<span class="token header-name keyword">x-content-type-options:</span>	nosniff
<span class="token header-name keyword">x-xss-protection:</span>	1; mode=block


</code></pre></div><h2 id="header"><a href="#header" class="header-anchor">#</a> Header</h2> <h3 id="connection-keep-alive"><a href="#connection-keep-alive" class="header-anchor">#</a> Connection: keep-alive</h3> <p>复用TCP连接，使用客户端到服务器的连接持续有效。当客户端对服务器有后续请求时，Keep-alive能够避免重建连接。</p> <h3 id="重定向"><a href="#重定向" class="header-anchor">#</a> 重定向</h3> <ul><li><p>301是永久重定向。</p></li> <li><p>302是临时重定向。</p></li> <li><p>共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）。</p></li> <li><p>不同点。</p> <ul><li>301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</li> <li>302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</li></ul></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/clinan/blog/edit/master/modules/technology/base/tcpip.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">7/11/2021, 10:04:54 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/modules/technology/base/algorithm.html" class="prev">算法</a></span> <span class="next"><a href="/modules/technology/base/binary.html">计算机组成原理</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c387313f.js" defer></script><script src="/assets/js/2.07d632c5.js" defer></script><script src="/assets/js/41.53f9abbe.js" defer></script>
  </body>
</html>
