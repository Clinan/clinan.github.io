<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java多线程 | 克林</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="stylesheet" href="https://cdn.clinan.xyz/fontawesome.css">
    <meta name="description" content="生活、技术、摄影">
    
    <link rel="preload" href="/assets/css/0.styles.cc6be2d6.css" as="style"><link rel="preload" href="/assets/js/app.c387313f.js" as="script"><link rel="preload" href="/assets/js/2.07d632c5.js" as="script"><link rel="preload" href="/assets/js/53.163cbc01.js" as="script"><link rel="prefetch" href="/assets/js/10.7b164219.js"><link rel="prefetch" href="/assets/js/11.f26295a2.js"><link rel="prefetch" href="/assets/js/12.215e9bd1.js"><link rel="prefetch" href="/assets/js/13.916a1030.js"><link rel="prefetch" href="/assets/js/14.6ebe2f7d.js"><link rel="prefetch" href="/assets/js/15.99fd32fe.js"><link rel="prefetch" href="/assets/js/16.a701c814.js"><link rel="prefetch" href="/assets/js/17.031348b7.js"><link rel="prefetch" href="/assets/js/18.149256fc.js"><link rel="prefetch" href="/assets/js/19.e739899c.js"><link rel="prefetch" href="/assets/js/20.dcad2a56.js"><link rel="prefetch" href="/assets/js/21.057b7460.js"><link rel="prefetch" href="/assets/js/22.ce64e41c.js"><link rel="prefetch" href="/assets/js/23.daf19161.js"><link rel="prefetch" href="/assets/js/24.749d98a7.js"><link rel="prefetch" href="/assets/js/25.3a6551a2.js"><link rel="prefetch" href="/assets/js/26.67d5bf4f.js"><link rel="prefetch" href="/assets/js/27.d11f18f3.js"><link rel="prefetch" href="/assets/js/28.98119994.js"><link rel="prefetch" href="/assets/js/29.f81591b4.js"><link rel="prefetch" href="/assets/js/3.925378c0.js"><link rel="prefetch" href="/assets/js/30.3d37f95f.js"><link rel="prefetch" href="/assets/js/31.6ddfa063.js"><link rel="prefetch" href="/assets/js/32.6782db54.js"><link rel="prefetch" href="/assets/js/33.c32aacff.js"><link rel="prefetch" href="/assets/js/34.0d6b18cf.js"><link rel="prefetch" href="/assets/js/35.90fa8707.js"><link rel="prefetch" href="/assets/js/36.b75b717d.js"><link rel="prefetch" href="/assets/js/37.d5574023.js"><link rel="prefetch" href="/assets/js/38.9666c5d9.js"><link rel="prefetch" href="/assets/js/39.be9b8db9.js"><link rel="prefetch" href="/assets/js/4.c338ef74.js"><link rel="prefetch" href="/assets/js/40.0496212f.js"><link rel="prefetch" href="/assets/js/41.53f9abbe.js"><link rel="prefetch" href="/assets/js/42.48e3621f.js"><link rel="prefetch" href="/assets/js/43.ded57d48.js"><link rel="prefetch" href="/assets/js/44.027366a5.js"><link rel="prefetch" href="/assets/js/45.270bebde.js"><link rel="prefetch" href="/assets/js/46.5cb35b21.js"><link rel="prefetch" href="/assets/js/47.9df7131a.js"><link rel="prefetch" href="/assets/js/48.58499a70.js"><link rel="prefetch" href="/assets/js/49.ca61ec46.js"><link rel="prefetch" href="/assets/js/5.ee90145e.js"><link rel="prefetch" href="/assets/js/50.237e199e.js"><link rel="prefetch" href="/assets/js/51.f571cf97.js"><link rel="prefetch" href="/assets/js/52.57d87431.js"><link rel="prefetch" href="/assets/js/54.22559499.js"><link rel="prefetch" href="/assets/js/55.7620fc70.js"><link rel="prefetch" href="/assets/js/56.dd45b171.js"><link rel="prefetch" href="/assets/js/57.1edff986.js"><link rel="prefetch" href="/assets/js/58.6ddb12e0.js"><link rel="prefetch" href="/assets/js/59.8243df7f.js"><link rel="prefetch" href="/assets/js/6.049d604b.js"><link rel="prefetch" href="/assets/js/60.665f6dc9.js"><link rel="prefetch" href="/assets/js/61.13f75167.js"><link rel="prefetch" href="/assets/js/62.cf46bf76.js"><link rel="prefetch" href="/assets/js/63.0bbbaeeb.js"><link rel="prefetch" href="/assets/js/64.d8daf8e4.js"><link rel="prefetch" href="/assets/js/65.5075cbc9.js"><link rel="prefetch" href="/assets/js/66.dfb3c850.js"><link rel="prefetch" href="/assets/js/67.c9920c80.js"><link rel="prefetch" href="/assets/js/68.7ba3806a.js"><link rel="prefetch" href="/assets/js/69.4df1b72c.js"><link rel="prefetch" href="/assets/js/7.61da790d.js"><link rel="prefetch" href="/assets/js/70.f44691e5.js"><link rel="prefetch" href="/assets/js/71.79e7b907.js"><link rel="prefetch" href="/assets/js/72.76c7a030.js"><link rel="prefetch" href="/assets/js/73.15d46a8c.js"><link rel="prefetch" href="/assets/js/74.7da23b80.js"><link rel="prefetch" href="/assets/js/75.2ab83637.js"><link rel="prefetch" href="/assets/js/76.fb7ef46f.js"><link rel="prefetch" href="/assets/js/77.c462d8d1.js"><link rel="prefetch" href="/assets/js/78.378764eb.js"><link rel="prefetch" href="/assets/js/8.f851a47e.js"><link rel="prefetch" href="/assets/js/9.9d6d487d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cc6be2d6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn.clinan.xyz/mini_logo.png" alt="克林" class="logo"> <span class="site-name can-hide">克林</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/modules/literature/" class="nav-link">现代文学</a></div><div class="nav-item"><a href="/modules/technology/" class="nav-link router-link-active">杂技奇谭</a></div><div class="nav-item"><a href="/modules/life/" class="nav-link">吃草日常</a></div><div class="nav-item"><a href="/modules/photography/" class="nav-link">无后期摄影</a></div> <a href="https://github.com/clinan/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/modules/literature/" class="nav-link">现代文学</a></div><div class="nav-item"><a href="/modules/technology/" class="nav-link router-link-active">杂技奇谭</a></div><div class="nav-item"><a href="/modules/life/" class="nav-link">吃草日常</a></div><div class="nav-item"><a href="/modules/photography/" class="nav-link">无后期摄影</a></div> <a href="https://github.com/clinan/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/modules/technology/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>架构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/modules/technology/java/JVM.html" class="sidebar-link">JAVA SE8虚拟机规范</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#类型" class="sidebar-link">类型</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#运行数据区" class="sidebar-link">运行数据区</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#对象" class="sidebar-link">对象</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#对象已死" class="sidebar-link">对象已死</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#垃圾收集算法" class="sidebar-link">垃圾收集算法</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#hotspot垃圾收集算法细节" class="sidebar-link">HOTSPOT垃圾收集算法细节</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#并行与并发" class="sidebar-link">并行与并发</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#收集器" class="sidebar-link">收集器</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#类文件结构" class="sidebar-link">类文件结构</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#jvm-类加载" class="sidebar-link">JVM 类加载</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#类加载器" class="sidebar-link">类加载器</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#虚拟机字节码执行引擎" class="sidebar-link">虚拟机字节码执行引擎</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#前端编译与优化" class="sidebar-link">前端编译与优化</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#后端编译与优化" class="sidebar-link">后端编译与优化</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#java内存模型" class="sidebar-link">Java内存模型</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#线程安全与锁优化" class="sidebar-link">线程安全与锁优化</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/JVM.html#特别的" class="sidebar-link">特别的</a></li></ul></li><li><a href="/modules/technology/java/big_data_export.html" class="sidebar-link">大数据量导出</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/java/big_data_export.html#结果" class="sidebar-link">结果</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/big_data_export.html#sax" class="sidebar-link">SAX</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/big_data_export.html#注意内存的回收" class="sidebar-link">注意内存的回收</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/big_data_export.html#代码" class="sidebar-link">代码</a></li></ul></li><li><a href="/modules/technology/java/tomcat.html" class="sidebar-link">tomcat</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/java/tomcat.html#servlet容器" class="sidebar-link">Servlet容器</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/tomcat.html#connector连接器" class="sidebar-link">Connector连接器</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/tomcat.html#container接口" class="sidebar-link">Container接口</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/tomcat.html#载入器" class="sidebar-link">载入器</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/tomcat.html#session" class="sidebar-link">Session</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/tomcat.html#security" class="sidebar-link">Security</a></li></ul></li><li><a href="/modules/technology/java/java.html" class="sidebar-link">Java</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#concurrenthashmap" class="sidebar-link">ConcurrentHashMap</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#hashmap" class="sidebar-link">HashMap</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#reentrantlock" class="sidebar-link">ReentrantLock</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#linkedhashmap的实现" class="sidebar-link">LinkedHashMap的实现</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#stringbuider和stringbuffer" class="sidebar-link">StringBuider和StringBuffer</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#linkedblockingqueue的实现" class="sidebar-link">LinkedBlockingQueue的实现</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#concurrentlinkedqueue" class="sidebar-link">ConcurrentLinkedQueue</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/java.html#threadlocal-内存泄露问题" class="sidebar-link">ThreadLocal 内存泄露问题</a></li></ul></li><li><a href="/modules/technology/java/concurrent.html" aria-current="page" class="active sidebar-link">Java多线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#并发编程的挑战" class="sidebar-link">并发编程的挑战</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#java并发机制的底层实现原理" class="sidebar-link">Java并发机制的底层实现原理</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#java内存模型" class="sidebar-link">Java内存模型</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#java并发编程基础" class="sidebar-link">Java并发编程基础</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#java中的锁" class="sidebar-link">Java中的锁</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#java并发容器和框架" class="sidebar-link">Java并发容器和框架</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#_13个原子操作类" class="sidebar-link">13个原子操作类</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#并发工具类" class="sidebar-link">并发工具类</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#线程池" class="sidebar-link">线程池</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#executor框架" class="sidebar-link">Executor框架</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/concurrent.html#实战" class="sidebar-link">实战</a></li></ul></li><li><a href="/modules/technology/java/Netty.html" class="sidebar-link">Netty</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/java/Netty.html#netty的优点和比较" class="sidebar-link">netty的优点和比较</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/Netty.html#基本概念介绍" class="sidebar-link">基本概念介绍</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/Netty.html#channel" class="sidebar-link">Channel</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/Netty.html#eventloop和线程模型" class="sidebar-link">EventLoop和线程模型</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/Netty.html#bytebuf-数据容器" class="sidebar-link">ByteBuf -数据容器</a></li></ul></li><li><a href="/modules/technology/java/netty源码解析.html" class="sidebar-link">Netty源码解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/modules/technology/java/netty源码解析.html#原生javanio" class="sidebar-link">原生JavaNIO</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/netty源码解析.html#如何绑定端口" class="sidebar-link">如何绑定端口</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/netty源码解析.html#pipeline流程" class="sidebar-link">Pipeline流程</a></li><li class="sidebar-sub-header"><a href="/modules/technology/java/netty源码解析.html#netty是如何对selector进行优化的" class="sidebar-link">Netty是如何对Selector进行优化的</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>DB</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringCloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux(Debian)</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java多线程"><a href="#java多线程" class="header-anchor">#</a> Java多线程</h1> <p>本文基于《Java并发编程的艺术》</p> <h2 id="并发编程的挑战"><a href="#并发编程的挑战" class="header-anchor">#</a> 并发编程的挑战</h2> <h2 id="java并发机制的底层实现原理"><a href="#java并发机制的底层实现原理" class="header-anchor">#</a> Java并发机制的底层实现原理</h2> <h3 id="volatile的应用"><a href="#volatile的应用" class="header-anchor">#</a> <code>volatile</code>的应用</h3> <h4 id="定义和实现原理"><a href="#定义和实现原理" class="header-anchor">#</a> 定义和实现原理</h4> <p><code>volatile</code>是如何来保证可见性的呢？让我们在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对<code>volatile</code>进行写操作时CPU会做什么事情。</p> <p><code>Java</code>代码如下。</p> <div class="language-java extra-class"><pre class="language-java"><code>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//  instance 是 volatile 变量</span>
</code></pre></div><p>转变成汇编代码，如下。</p> <div class="language-assembly extra-class"><pre class="language-text"><code>0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);
</code></pre></div><h4 id="lock前缀的指令在多核处理器下会引发了两件事情"><a href="#lock前缀的指令在多核处理器下会引发了两件事情" class="header-anchor">#</a> <code>Lock</code>前缀的指令在多核处理器下会引发了两件事情</h4> <p><strong><code>Lock</code>前缀指令会引起处理器缓存回写到内存</strong>
这个涉及到处理器的硬件实现。和代码无关。有的是锁总线，锁总线当前线程会独占共享内存；有的是锁缓存。</p> <p><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong></p> <p><code>IA-32</code>处理器和<code>Intel 64</code>处理器使用 MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。</p> <h3 id="synchronized的实现原理和优化"><a href="#synchronized的实现原理和优化" class="header-anchor">#</a> <code>synchronized</code>的实现原理和优化</h3> <p><code>java</code>中的每一个对象都可以作为锁，主要有这三种</p> <ul><li>对于普通方法，锁是当前实例对象。</li> <li>对于静态同步方法，锁是当前类的Class对象</li> <li>对于同步块方法，锁是<code>synchronized</code>括号里的对象</li></ul> <h4 id="将缓存数据刷回主存"><a href="#将缓存数据刷回主存" class="header-anchor">#</a> 将缓存数据刷回主存</h4> <p><strong>离开一个<code>synchronized</code>块会导致当前线程所有写入到缓存的数据刷新，进入一个<code>synchronized</code>块会导致所有可变数据重新从主存获取。</strong></p> <h4 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h4> <p>级别从低到高：无锁，偏向锁，轻量锁，重量锁。锁的状态会随着竞争情况逐渐升级。但不能降级。</p> <table><thead><tr><th>锁</th> <th>优点</th> <th>缺点</th> <th>使用场景</th></tr></thead> <tbody><tr><td>偏向锁</td> <td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差距</td> <td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td> <td>适用于只有一个线程访问同步语块</td></tr> <tr><td>轻量级锁</td> <td>竞争的线程不会阻塞，而是自旋等待。提高了程序的响应速度</td> <td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td> <td>追求响应时间，同步语块执行速度非常快</td></tr> <tr><td>重量级锁</td> <td>线程竞争不使用线程，不会消耗CPU</td> <td>线程阻塞，响应时间缓慢</td> <td>追求吞吐量，同步语块执行速度慢</td></tr></tbody></table> <h2 id="java内存模型"><a href="#java内存模型" class="header-anchor">#</a> <code>Java</code>内存模型</h2> <h3 id="多线程通信-jmm"><a href="#多线程通信-jmm" class="header-anchor">#</a> 多线程通信 JMM</h3> <p><img src="https://cdn.clinan.xyz/jmm.png" alt="jmm"></p> <h3 id="指令重排序"><a href="#指令重排序" class="header-anchor">#</a> 指令重排序</h3> <ul><li><p>编译器优化的重排序，编译器在不改变单线程程序执行语义的情况下，可以重新安排语句的执行顺序。</p></li> <li><p>指令并行的重排序。指令级并行的重排序。现代处理器采用了指令级并行技术（ <code>Instruction-LevelParallelism, ILP</code>）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li> <li><p>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><p>上述的1属于编译器重排序，2和 3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求 Java编译器在生成指令序列时，插入特定类型的内存屏障<code>Memory Barriers</code>， Intel称之为 <code>Memory Fence</code>）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p></li></ul> <p><strong>JMM属于语言级的内存模型</strong>，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为 程序员提供一致的内存可见性保证 。</p> <h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="header-anchor">#</a> <code>volatile</code>的内存语义</h3> <p><code>volatile</code>变量自身具有下列特性</p> <ul><li>可见性，对一个<code>volatile</code>变量的读，总是能看到（任意线程）对这个<code>volatile</code>变量最后的写入。</li> <li><s>原子性</s> ，对任意单个<code>volatile</code>变量的读/写具有原子性，但类似于<code>volatile++</code>这种复合操作不具有原子性。</li></ul> <h4 id="volatile重排序规则"><a href="#volatile重排序规则" class="header-anchor">#</a> <code>volatile</code>重排序规则</h4> <ul><li>当<strong>第二个</strong>操作是<code>volatile</code>写的时候，不管第一个操作是什么，都不能重排序。这个规则确保<code>volatile</code>写之前的操作不会被编译器重排序到<code>volatile</code>写之后。</li> <li>当<strong>第一个</strong>操作是<code>volatile</code>读时，不管第二个操作是什么，都不能重排序。这个规则确保<code>volatile</code>读之后的操作不会被编译器重排序到<code>volatile</code>读之前。</li> <li>第一个操作是<code>volatile</code>写，第二个操作时<code>volatile</code>读时，不能重排序。</li></ul> <p>为了实现<code>volatile</code>的内存语义，编译器在生成字节码时，会在</p> <h3 id="锁的内存语义"><a href="#锁的内存语义" class="header-anchor">#</a> 锁的内存语义</h3> <p>以<code>JUC</code>包的<code>ReentrantLock</code>作为例子。</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><h5 id="对公平锁和给公平锁的内存语义的总结"><a href="#对公平锁和给公平锁的内存语义的总结" class="header-anchor">#</a> 对公平锁和给公平锁的内存语义的总结</h5> <ul><li>公平锁和非公平锁进行释放时，最后都要写一个<code>volatile</code>的变量<code>state</code></li> <li>公平锁获取时，首先会去读<code>volatile</code>变量<code>state</code></li> <li>非公平锁获取时，首先会用<code>CAS</code>更新<code>volatile</code>变量，这个操作同时具有<code>volatile</code>读和<code>volatile</code>写的内存语义</li></ul> <p>锁释放和锁获取至少有以下两种方式</p> <ul><li>利用<code>volatile</code>变量的读-写锁具有的内存语义</li> <li>利用<code>CAS</code>所附带的<code>volatile</code>读和<code>volatile</code>写的内存语义</li></ul> <h3 id="final的内存语义"><a href="#final的内存语义" class="header-anchor">#</a> <code>final</code>的内存语义</h3> <p>两个重排序规则</p> <ul><li>在构造函数内对一个<code>final</code>域的写入，与随后把这个构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li> <li>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序。</li></ul> <p>读<code>final</code>域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的<code>final</code>域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读<code>final</code>域操作的前面插入一个<code>LoadLoad</code>屏障。</p> <h3 id="happens-before"><a href="#happens-before" class="header-anchor">#</a> happens-before</h3> <p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在<code>happens-befor</code>e关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p> <p>*《JSR-133:JavaMemoryModelandThreadSpecification》*定义了如下<code>happens-before</code>规则。</p> <ol><li>程序顺序规则：一个线程中的每个操作，<code>happens-before</code>于该线程中的任意后续操作。</li> <li>监视器锁规则：对一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁。</li> <li><code>volatile</code>变量规则：对一个<code>volatile</code>域的写，<code>happens-before</code>于任意后续对这个<code>volatile</code>域的读。</li> <li>传递性：如果<code>A happens-before B</code>，且<code>B happens-before C</code>，那么<code>A happens-before C</code>。</li> <li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么A线程的<code>ThreadB.start()</code>操作<code>happens-before</code>于线程B中的任意操作。</li> <li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作<code>happens-before</code>于线程A从<code>ThreadB.join()</code>操作成功返回。</li></ol> <h3 id="双重检查锁定-double-checked-locking"><a href="#双重检查锁定-double-checked-locking" class="header-anchor">#</a> 双重检查锁定，double-checked locking</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token comment">// volatile 关键字保证，当uniqueInstance被实例时，多个线程能正确的获取uniqueInstance变量</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 检查实例，如果不存在就进入同步块</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 注意，只有第一次才彻底执行这里的代码</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 进入同步块后，再次检查，如果还是null才创建。</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="延迟初始化"><a href="#延迟初始化" class="header-anchor">#</a> 延迟初始化</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">InstanceFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InstanceHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Instance</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Instance</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里将导致 InstanceHolder 类被加载并初始化</span>
        <span class="token keyword">return</span> <span class="token class-name">InstanceHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="java并发编程基础"><a href="#java并发编程基础" class="header-anchor">#</a> Java并发编程基础</h2> <p>Java线程状态</p> <table><thead><tr><th>状态名称</th> <th>说明</th></tr></thead> <tbody><tr><td><code>new</code></td> <td>创建完成，但是还没有执行<code>start()</code>方法</td></tr> <tr><td><code>runnable</code></td> <td>运行中</td></tr> <tr><td><code>blocked</code></td> <td>堵塞，标识线程被锁堵塞着</td></tr> <tr><td><code>waiting</code></td> <td>等待其他线程做出一些特定操作，如通知或中断</td></tr> <tr><td><code>time_waiting</code></td> <td>超时等待状态，它是可以在指定时间自行返回的</td></tr> <tr><td><code>terminated</code></td> <td>终止状态，线程执行完毕</td></tr></tbody></table> <h2 id="java中的锁"><a href="#java中的锁" class="header-anchor">#</a> Java中的锁</h2> <h3 id="lock接口"><a href="#lock接口" class="header-anchor">#</a> Lock接口</h3> <blockquote><p>定义了锁获取和释放的一系列操作，并能提供<code>synchronized</code>关键字不具备的特质</p></blockquote> <ul><li><strong>尝试非阻塞地获取锁</strong>：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁。</li> <li><strong>能被中断地获取锁</strong>：与<code>synchronized</code>不同，获取锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放。</li> <li><strong>超时获取锁🔐</strong>：在指定的时间之前获取锁，如果截止时间到了仍旧无法获得锁，则返回。</li></ul> <h3 id="队列同步器aqs"><a href="#队列同步器aqs" class="header-anchor">#</a> 队列同步器AQS</h3> <p><code>AbstractQueuedSynchronizer</code>又被称为<code>AQS</code>。提供模板方法，其中<code>FailSync</code>和<code>nonFailSync</code>等都是基于AQS实现的。</p> <h3 id="能够覆盖的模板方法。"><a href="#能够覆盖的模板方法。" class="header-anchor">#</a> 能够覆盖的模板方法。</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomLock</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="reentrantlock"><a href="#reentrantlock" class="header-anchor">#</a> <code>ReentrantLock</code></h3> <h4 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 非公平锁</span>
    <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 公平锁</span>
    <span class="token comment">// lock = new ReentrantLock(true);</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 最后释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>重入锁和<code>synchronized</code>关键字的区别</p> <ul><li>重入锁能够超时获取锁，并触发中断</li> <li>重入锁判断的是<code>AQS</code>里的<code>state</code>字段，而<code>synchronized</code>判断的是对象头。两者都避免锁的获取不在用户态和内核态之间进行切换</li> <li><code>synchronized</code>是<strong>非公平锁</strong>，如果要实现公平锁，只能使用<code>ReentrantLock</code></li> <li><code>synchronized</code>关键字实现了偏向锁，自旋锁，性能上和<code>ReentrantLock</code>基本一样</li> <li><code>ReentrantLock</code>提供了<code>newCondition</code>方法，可以通过<code>Condition.await()</code>和<code>Condition.signal()</code>方法来阻塞唤醒指定的线程或是线程组</li></ul> <h4 id="公平锁和非公平锁的区别"><a href="#公平锁和非公平锁的区别" class="header-anchor">#</a> 公平锁和非公平锁的区别</h4> <ul><li><p>公平锁会在有新的线程进来的时候，首先判断下队列中是否有线程在等待，如果有，则加入队列</p></li> <li><p>非公平锁会先尝试获取锁，如果获取失败，就加入队列。</p></li> <li><p>性能上，公平锁的性能会比非公平锁低，因为公平锁会导致过多的线程切换，影响吞吐率。但是非公平锁可能会导致<strong>线程饥饿</strong>的问题</p></li></ul> <h3 id="reentrantreadwritelock"><a href="#reentrantreadwritelock" class="header-anchor">#</a> <code>ReentrantReadWriteLock</code></h3> <p><code>ReentrantLock</code>和<code>synchronized</code>关键字都是<strong>排他锁（独占锁）</strong>，这些锁在同一时刻只允许一个线程访问，而读写锁（<code>ReentrantReadWriteLock</code>）可以允许多个线程访问。**读锁是共享锁，写锁是排他锁。读锁和写锁互斥。**在性能上<code>ReentrantReadWriteLock</code>比<code>ReentrantLock</code>好。</p> <p>TODO</p> <h3 id="stampedlock"><a href="#stampedlock" class="header-anchor">#</a> <code>StampedLock</code></h3> <p><code>stamped</code>印有印章的印记，<strong>不是重入锁</strong>🔒</p> <p><code>ReentrantReadWriteLock</code>使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的。</p> <p>但是，读写锁如果使用不当，很容易产生“饥饿”问题：</p> <p>比如在读线程非常多，写线程很少的情况下，很容易导致写线程“饥饿”，虽然使用“公平”策略可以一定程度上缓解这个问题，但是“公平”策略是以牺牲系统吞吐量为代价的。</p> <h4 id="stampedlock的特点"><a href="#stampedlock的特点" class="header-anchor">#</a> StampedLock的特点</h4> <p><code>try</code>系列获取锁的函数，当获取锁失败后会返回为0的<code>stamp</code>值。当调用释放锁和转换锁的方法时候需要传入获取锁时候返回的<code>stamp</code>值。</p> <p><code>StampedLockd</code>的内部实现是基于<code>CLH</code>锁的，<code>CLH</code>锁原理：锁维护着一个等待线程队列，所有申请锁且失败的线程都记录在队列。一个节点代表一个线程，</p> <p>保存着一个标记位<code>locked</code>,用以判断当前线程是否已经释放锁。当一个线程试图获取锁时，从队列尾节点作为前序节点，循环判断所有的前序节点是否已经成功释放锁。</p> <p><a href="https://cloud.tencent.com/developer/article/1470988" target="_blank" rel="noopener noreferrer">JDK8中新增的StampedLock<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="locksupport"><a href="#locksupport" class="header-anchor">#</a> <code>LockSupport</code></h3> <p>用于阻塞或唤醒线程</p> <p>用法</p> <div class="language-java extra-class"><pre class="language-java"><code> <span class="token comment">// 阻塞当前线程</span>
 <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 线程的功能，其中参数 blocker是用来标识当前线程在等待的对象，该对象主要用于问题排查和系统监控。</span>
 <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 等待的超时时间，单位毫秒</span>
 <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// deadline是绝对时间，毫秒</span>
 <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">parkUntil</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 唤醒线程</span>
 <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="condition"><a href="#condition" class="header-anchor">#</a> <code>Condition</code></h3> <p><code>Condition</code>是<code>Lock#newCondition</code>创建出来的</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">conditionWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">conditionSignal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>TODO</p> <h2 id="java并发容器和框架"><a href="#java并发容器和框架" class="header-anchor">#</a> Java并发容器和框架</h2> <h3 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> <code>ConcurrentHashMap</code></h3> <p>TODO</p> <h3 id="java中的阻塞队列"><a href="#java中的阻塞队列" class="header-anchor">#</a> Java中的阻塞队列</h3> <p>阻塞队列是一个支持阻塞的插入和移除方法的队列：</p> <ul><li>支持阻塞的插入方法：当队列满时，阻塞插入元素的线程，直到队列中有元素被移除</li> <li>支持阻塞的移除方法：当队列空时，获取队列元素的线程会一直等待，知道取得队列中的元素</li></ul> <h4 id="arrayblockingqueue数组结构组成的有界阻塞队列"><a href="#arrayblockingqueue数组结构组成的有界阻塞队列" class="header-anchor">#</a> <code>ArrayBlockingQueue</code>数组结构组成的有界阻塞队列</h4> <p>按照FIFO的原则对元素进行排序。可以选择是否保证队列的公平性，访问者的公平性是基于可重入锁<code>ReentrantLock</code>实现的</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayBlockingQueue</span> fairQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="linkedblockingqueue链表实现的有界阻塞队列"><a href="#linkedblockingqueue链表实现的有界阻塞队列" class="header-anchor">#</a> <code>LinkedBlockingQueue</code>链表实现的有界阻塞队列</h4> <p>默认长度并且是最大长度为<code>Integer.MAX_VALUE</code>。<strong>FIFO</strong></p> <h4 id="priorityblockingqueue支持优先级的无界阻塞队列-数组实现"><a href="#priorityblockingqueue支持优先级的无界阻塞队列-数组实现" class="header-anchor">#</a> <code>PriorityBlockingQueue</code>支持优先级的无界阻塞队列，数组实现</h4> <p>默认情况下元素按照升序排序。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者在初始化<code>PriorityBlockingQueue</code>时，指定<code>Comparator</code>来对元素进行排序。</p> <h4 id="delayqueue支持延时获取元素的无界阻塞队列"><a href="#delayqueue支持延时获取元素的无界阻塞队列" class="header-anchor">#</a> <code>DelayQueue</code>支持延时获取元素的无界阻塞队列</h4> <p>是<code>PriorityQueue</code>的子类</p> <h4 id="synchronousqueue不存储元素的阻塞队列"><a href="#synchronousqueue不存储元素的阻塞队列" class="header-anchor">#</a> <code>SynchronousQueue</code>不存储元素的阻塞队列</h4> <p>每一个<code>put</code>操作必须等待一个<code>take</code>操作，否则不能继续添加元素。可以把<code>SynchronousQueue</code>看成传球手，负责把生产者线程处理的数据直接给消费者线程。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">SynchronousQueue</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    transferer <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TransferQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TransferStack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="linkedtransferqueue链表实现的无界阻塞队列"><a href="#linkedtransferqueue链表实现的无界阻塞队列" class="header-anchor">#</a> <code>LinkedTransferQueue</code>链表实现的无界阻塞队列</h4> <p>相比于其他阻塞队列，<code>LinkedTransferQueue</code>多了<code>tryTransfer</code>和<code>transfer</code>方法。</p> <ul><li><p><code>transfer</code>方法</p> <p>如果当前有消费者正在等待接收元素（使用<code>take()</code>或<code>poll()</code>方法时），<code>transfer()</code>方法可以把生产者传入的元素立刻<code>transfer</code>给消费者。如果没有消费者在等待接收元素，<code>transfer</code>会将元素放在队列的<code>tail</code>节点，<strong>并等待被消费者消费了才返回</strong>。</p></li> <li><p><code>tryTransfer</code>方法</p> <p><code>tryTransfer</code>方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回<code>false</code>。和<code>transfer</code>方法的区别是<code>tryTransfer</code>方法无论消费者是否接收，方法立即返回，而<code>transfer</code>方法是必须等到消费者消费了才返回。</p></li></ul> <h4 id="linkedblockingdueue链表实现的双向阻塞队列"><a href="#linkedblockingdueue链表实现的双向阻塞队列" class="header-anchor">#</a> <code>LinkedBlockingDueue</code>链表实现的双向阻塞队列</h4> <p><code>LinkedBlockingDeque</code>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，<code>LinkedBlockingDeque</code>多了<code>addFirst、addLast、offerFirst、offerLast、peekFirst</code>和<code>peekLast</code>等方法，以<code>First</code>单词结尾的方法，表示插入、获取（<code>peek</code>）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法<code>add</code>等同于<code>addLast</code>，移除方法<code>remove</code>等效于<code>removeFirst</code>。但是<code>take</code>方法却等同于<code>takeFirst</code>，不知道是不是JDK的bug，使用时还是用带有First和<code>Last</code>后缀的方法更清楚。在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。</p> <p>另外，双向阻塞队列可以运用在“工作窃取”模式中。</p> <h4 id="concurrentlinkendqueue"><a href="#concurrentlinkendqueue" class="header-anchor">#</a> <code>ConcurrentLinkendQueue</code></h4> <p>TODO</p> <h3 id="fork-join框架"><a href="#fork-join框架" class="header-anchor">#</a> Fork/Join框架</h3> <p><code>Fork/Join</code>框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><h4 id="工作窃取算法"><a href="#工作窃取算法" class="header-anchor">#</a> 工作窃取算法</h4> <p>双向队列，被窃取的任务线程永远从双向队列的头部拿任务执行，而窃取任务的线程永远从双向队列的尾部拿任务执行。</p> <h4 id="使用-2"><a href="#使用-2" class="header-anchor">#</a> 使用</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threshold <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">&lt;=</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">+</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token class-name">CountTask</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">CountTask</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t1<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            t2<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum <span class="token operator">=</span> t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ForkJoinPool</span> forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ForkJoinTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> submit <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> ret <span class="token operator">=</span> submit<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_13个原子操作类"><a href="#_13个原子操作类" class="header-anchor">#</a> 13个原子操作类</h2> <h3 id="基本类型"><a href="#基本类型" class="header-anchor">#</a> 基本类型</h3> <h4 id="atomicboolean"><a href="#atomicboolean" class="header-anchor">#</a> AtomicBoolean</h4> <h4 id="atomicinteger"><a href="#atomicinteger" class="header-anchor">#</a> AtomicInteger</h4> <h4 id="atomiclong"><a href="#atomiclong" class="header-anchor">#</a> AtomicLong</h4> <h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <h4 id="atomicintegerarray"><a href="#atomicintegerarray" class="header-anchor">#</a> AtomicIntegerArray</h4> <h4 id="atomicreferencearray"><a href="#atomicreferencearray" class="header-anchor">#</a> AtomicReferenceArray</h4> <h4 id="atomiclongarray"><a href="#atomiclongarray" class="header-anchor">#</a> AtomicLongArray</h4> <h3 id="引用类型"><a href="#引用类型" class="header-anchor">#</a> 引用类型</h3> <h4 id="atomicmarkablereference"><a href="#atomicmarkablereference" class="header-anchor">#</a> AtomicMarkableReference</h4> <h4 id="atomicreference"><a href="#atomicreference" class="header-anchor">#</a> AtomicReference</h4> <h4 id="atomicstampedreference"><a href="#atomicstampedreference" class="header-anchor">#</a> AtomicStampedReference</h4> <h3 id="更新字段"><a href="#更新字段" class="header-anchor">#</a> 更新字段</h3> <h4 id="atomiclongfieldupdater"><a href="#atomiclongfieldupdater" class="header-anchor">#</a> AtomicLongFieldUpdater</h4> <h4 id="atomicintegerfieldupdater"><a href="#atomicintegerfieldupdater" class="header-anchor">#</a> AtomicIntegerFieldUpdater</h4> <h4 id="atomicreferencefieldupdater"><a href="#atomicreferencefieldupdater" class="header-anchor">#</a> AtomicReferenceFieldUpdater</h4> <h2 id="并发工具类"><a href="#并发工具类" class="header-anchor">#</a> 并发工具类</h2> <h3 id="等待多线程完成的countdownlatch"><a href="#等待多线程完成的countdownlatch" class="header-anchor">#</a> 等待多线程完成的<code>CountDownLatch</code></h3> <p><code>CountDownLatch</code>的构造函数接收一个<code>int</code>参数作为计数器，表示等待N个点完成。当调用<code>countDown</code>方法时，计数器就会减一。 这里的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。例如解析<code>Excel</code>的sheet。</p> <h4 id="使用-3"><a href="#使用-3" class="header-anchor">#</a> 使用</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchTester</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程内打印&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="同步屏障cyclicbarrier"><a href="#同步屏障cyclicbarrier" class="header-anchor">#</a> 同步屏障<code>CyclicBarrier</code></h3> <p><code>CyclicBarrier</code>的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。主要作用是让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程（包括主线程）到达屏障时，屏障才会开门，所有被拦截的线程才会继续运行。</p> <p>和<code>CountDownLatch</code>相比，<code>CyclicBarrier</code>可以被重复使用，还提供一些了解阻塞线程信息的方法。</p> <h4 id="使用-4"><a href="#使用-4" class="header-anchor">#</a> 使用</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierTester</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">CyclicBarrier</span> cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sub thread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sub thread were finished&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 重置方法</span>
        <span class="token comment">// cyclicBarrier.reset();</span>
        <span class="token comment">// 获取阻塞的线程数量的方法</span>
        <span class="token comment">// cyclicBarrier.getNumberWaiting();</span>
        cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sub thread were finished&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="控制并发线程数semaphore"><a href="#控制并发线程数semaphore" class="header-anchor">#</a> 控制并发线程数<code>Semaphore</code></h3> <p><code>Semaphore</code>信号量。是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p> <h3 id="使用-5"><a href="#使用-5" class="header-anchor">#</a> 使用</h3> <p><code>Semaphore</code>可以用来做流量控制。加入有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的去读取，但是如果读到内存后，还需要存储到数据库中，而数据库连接数只有10个，这时我们必须控制只有10个线程能够获取数据库链接来保存数据。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreTester</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THREAD_COUNT <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>THREAD_COUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 最后只能有10个线程获取到数据库连接池</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;模拟插入数据到数据库&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 会等待所有线程执行完成才会关闭</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="线程间交换数据的exchanger"><a href="#线程间交换数据的exchanger" class="header-anchor">#</a> 线程间交换数据的<code>Exchanger</code></h3> <p><code>Exchanger</code>（交换者）是一个用于线程间协作，进行数据交换的工具类。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过<code>exchange</code>方法<strong>交换数据</strong>。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExchangerTester</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> exchanger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> a <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">&quot;wdnmd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;first thread: &quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> c <span class="token operator">=</span> exchanger<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;second thread: &quot;</span> <span class="token operator">+</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 会等待所有线程执行完成才会关闭</span>
        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// second thread: wdnmd</span>
    <span class="token comment">// first thread: C</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <h3 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h3> <ul><li><code>corePoolSize</code> – the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set</li> <li><code>maximumPoolSize</code> – the maximum number of threads to allow in the pool</li> <li><code>keepAliveTime</code> – 当线程数大于核心数时，多余的空闲线程在终止前等待新任务的最长时间。</li> <li><code>unit</code> – the time unit for the keepAliveTime argument</li> <li><code>workQueue</code> – the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.</li> <li><code>threadFactory</code> – the factory to use when the executor creates a new thread，默认<code>DefaultThreadFactory</code></li> <li><code>handler</code> – the handler to use when execution is blocked because the thread bounds and queue capacities are reached， 默认是<code>AbortPolicy</code></li></ul> <h3 id="线程池的好处"><a href="#线程池的好处" class="header-anchor">#</a> 线程池的好处</h3> <ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li> <li>提高响应速度。当任务到达时，任务可以不需要等到创建线程就能立即执行</li> <li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li></ol> <h3 id="线程池的主要处理流程"><a href="#线程池的主要处理流程" class="header-anchor">#</a> 线程池的主要处理流程</h3> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><h3 id="线程池的状态"><a href="#线程池的状态" class="header-anchor">#</a> 线程池的状态</h3> <p>线程状态取的是变量<code>ctl</code>的最高三位，剩下的29位记录woker的数量</p> <table><thead><tr><th>state</th> <th>description</th> <th>值</th></tr></thead> <tbody><tr><td>RUNNING</td> <td>接收新任务，并处理排队任务</td> <td>111</td></tr> <tr><td>SHUTDOWN</td> <td>不接收新任务，但处理排队任务</td> <td>000</td></tr> <tr><td>STOP</td> <td>不接收新任务，不处理排队任务，并中断正在进行的任务</td> <td>001</td></tr> <tr><td>tidying</td> <td>所有任务终止，workerCount=0，转换到tidying状态的任务将会执行terminate()的钩子方法</td> <td>010</td></tr> <tr><td>terminated</td> <td>terminated()方法已完成</td> <td>011</td></tr></tbody></table> <ul><li>调用<code>shutdown</code>方法，<code>RUNNING</code>状态转为<code>SHUTDOWN</code>。当<strong>线程池和队列都为空</strong>的时候，状态变为<code>TIDYING</code></li> <li>调用<code>shutdownNow</code>方法，<code>RUNNING</code>状态转为<code>STOP</code>。当<strong>线程池为空</strong>时，状态变为<code>TIDYING</code></li> <li>当调用<code>terminate()</code>钩子方法完成后，awaitTerminate方法中的线程状态都变为<code>terminate</code>后。状态从<code>TIDYING</code>变为<code>terminated</code>。</li></ul> <h3 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="header-anchor">#</a> 线程池拒绝策略</h3> <ul><li><code>AbortPolicy</code>：直接拒绝，并抛出一个运行时异常：<code>RejectedExecutionException</code></li> <li><code>DiscardPolicy</code>：拒绝加入的任务，但是是静默的，不抛出任何异常</li> <li><code>DiscardOldestPolicy</code>：忽略（丢弃）下一个要执行的任务，如果刚好有可用的线程，则立即提交执行。</li> <li><code>CallerRunsPolicy</code>：被拒绝任务的处理程序，它直接在execute方法的<strong>调用线程中运行</strong>被拒绝的任务，除非执行程序已关闭，在这种情况下任务将被丢弃。</li></ul> <h3 id="线程池10问10答"><a href="#线程池10问10答" class="header-anchor">#</a> 线程池10问10答</h3> <ol><li><h4 id="corepoolsize-0会怎么样"><a href="#corepoolsize-0会怎么样" class="header-anchor">#</a> corePoolSize=0会怎么样</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// execute(Runable command) 方法</span>
<span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// workQueue.offer(command) 添加到队列，如果添加成功，返回false</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 第一个submit的runable，!isRunning会返回false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果工作线程数量为0， 则直接添加一个非核心工作线程</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>因此可以知道下面这段代码其实也是会执行，并打印信息的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> objects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">final</span> <span class="token class-name">ThreadPoolExecutor</span> threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> finalI <span class="token operator">=</span> i<span class="token punctuation">;</span>
    threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@SneakyThrows</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>finalI<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><code>corePoolSize</code>和<code>maximumPoolSize</code>都设为0， 会抛出非法参数异常</p></li></ul></li> <li><h4 id="线程池创建的之后-会立即创建线程池吗"><a href="#线程池创建的之后-会立即创建线程池吗" class="header-anchor">#</a> 线程池创建的之后，会立即创建线程池吗</h4> <p><strong>不会</strong>。从上面的源码可以看出，创建完<code>ThreadPoolExecutor</code>之后，线程不会立即启动，而是要等到有任务提交的时候才会启动，除非调用了<code>prestartCoreThread</code>或者是<code>prestartAllCoreThreads</code>才会事先启动线程。</p> <ul><li><code>prestartCoreThread</code>：只预启动一个核心线程，如果核心线程设为0，则不会预先启动任何线程</li> <li><code>prestartAllCoreThreads</code>：启动所有的核心线程，如果核心线程设为0，则不会预先启动任何线程</li></ul></li> <li><h4 id="核心线程永远不会销毁吗"><a href="#核心线程永远不会销毁吗" class="header-anchor">#</a> 核心线程永远不会销毁吗？</h4> <p>在JDK1.6之后，如果allowsCoreThreadTimeOut=true，核心线程也可以被终止。</p></li> <li><h4 id="如何保证线程不被销毁"><a href="#如何保证线程不被销毁" class="header-anchor">#</a> 如何保证线程不被销毁</h4> <p>实现方式非常巧妙，核心线程（Worker）即使一直空闲也不终止，是通过workQueue.take()实现的，它会一直阻塞到从等待队列中取到新的任务。非核心线程空闲指定时间后终止是通过workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)实现的，一个空闲的Worker只等待keepAliveTime，如果还没有取到任务则循环终止，线程也就运行结束了。</p></li> <li><h4 id="空闲线程过多会有什么问题"><a href="#空闲线程过多会有什么问题" class="header-anchor">#</a> 空闲线程过多会有什么问题</h4> <ul><li><p>线程池保持空闲的核心线程是它的默认配置，一般来讲是没有问题的，因为它占用的内存一般不大。怕的就是业务代码中使用ThreadLocal缓存的数据过大又不清理。</p></li> <li><p>如果你的应用线程数处于高位，那么需要观察一下YoungGC的情况，估算一下Eden大小是否足够。如果不够的话，可能要谨慎地创建新线程，并且让空闲的线程终止；必要的时候，可能需要对JVM进行调参。</p></li></ul></li> <li><h4 id="keepalivetime-0会怎么样"><a href="#keepalivetime-0会怎么样" class="header-anchor">#</a> keepAliveTime=0会怎么样</h4> <p>在JDK1.8中，keepAliveTime=0表示非核心线程执行完立刻终止。</p> <p>默认情况下，keepAliveTime小于0，初始化的时候才会报错；但如果<code>allowsCoreThreadTimeOut</code>，<code>keepAliveTime</code>必须大于0，不然初始化报错。</p></li> <li><h4 id="怎么进行异常处理"><a href="#怎么进行异常处理" class="header-anchor">#</a> 怎么进行异常处理</h4> <ul><li>不论是用execute还是submit，都可以自己在业务代码上加try-catch进行异常处理。我一般喜欢使用这种方式，因为我喜欢对不同业务场景的异常进行差异化处理，至少打不一样的日志吧。</li> <li>如果是execute，还可以自定义线程池，继承ThreadPoolExecutor并复写其afterExecute(Runnable r, Throwable t)方法。</li> <li>或者实现<code>Thread.UncaughtExceptionHandler</code>接口，实现<code>void uncaughtException(Thread t, Throwable e);</code>方法，并将该handler传递给线程池的<code>ThreadFactory</code>。</li> <li>但是注意，afterExecute和UncaughtExceptionHandler都不适用submit。因为通过上面的FutureTask.run()不难发现，它自己对Throwable进行了try-catch，封装到了outcome属性，所以底层方法execute的Worker是拿不到异常信息的。</li></ul></li> <li><h4 id="如果是无界队列-线程数量会增加到最大线程数量吗"><a href="#如果是无界队列-线程数量会增加到最大线程数量吗" class="header-anchor">#</a> 如果是无界队列，线程数量会增加到最大线程数量吗</h4> <p>答：不会</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在这里workQueue.offer(command)会一直返回空，没有执行下面的elseif中添加非核心worker的代码</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h2 id="executor框架"><a href="#executor框架" class="header-anchor">#</a> <code>Executor</code>框架</h2> <p>在<code>HotSpot VM</code>的线程模型中，<code>Java</code>线程（<code>java.lang.Thread</code>）被一对一映射为本地操作系统线程。</p> <h3 id="executor框架的结构"><a href="#executor框架的结构" class="header-anchor">#</a> <code>Executor</code>框架的结构</h3> <p><code>Executor</code>框架主要由三大部分组成</p> <ul><li>任务。包括被执行任务需要实现的接口：<code>Runnable</code>接口或<code>Callable</code>接口</li> <li>任务的执行。包括任务执行机制的核心接口<code>Executor</code>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。<code>Executor</code>有两个关键类实现了<code>ExecutorService</code>接口（<code>ThreadPoolExecutor</code>和<code>ScheduledTreadPoolExecutor</code>）。</li> <li>异步计算的结果。包括接口<code>Future</code>和实现类<code>FutureTask</code></li></ul> <p>相关类和接口简介</p> <ul><li><p><code>TheadPoolExecutor</code>是线程池的核心实现类，用来执行被提交的任务。</p></li> <li><p><code>ScheduledThreadPoolExecutor</code>，可以在给定的延迟后运行命令，或定期执行命令。比Timer更灵活，且功能强大。</p></li> <li><p><code>Callable</code>和<code>Runnable</code>的不同在于，<code>Callable</code>可以返回数据给主线程。而<code>Runnable</code>只能返回给定的结果。所有提交的<code>Runnable</code>接口的实现，最后在创建<code>FutureTask</code>的时候，都会被转为<code>Callable</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ExecutorService中对于submit callable任务的定义</span>
<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h3 id="scheduledthreadpoolexecutor"><a href="#scheduledthreadpoolexecutor" class="header-anchor">#</a> <code>ScheduledThreadPoolExecutor</code></h3> <h4 id="相对于threadpoolexecutor的区别"><a href="#相对于threadpoolexecutor的区别" class="header-anchor">#</a> 相对于<code>ThreadPoolExecutor</code>的区别</h4> <ol><li>使用<code>DelayQueue</code>作为任务队列</li> <li>获取任务的方式不同</li> <li>执行周期任务后，增加了额外操作</li></ol> <h4 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h4> <p><code>ScheduledThreadPoolExecutor</code>会把待调度的<code>ScheduledFurtureTask</code>放到一个<code>DelayQueue</code>中。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ScheduledFutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 添加到队列中的序号</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> sequenceNumber<span class="token punctuation">;</span>
    <span class="token comment">// 这个任务将要执行的具体时间</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> time<span class="token punctuation">;</span>
    <span class="token comment">// 表示任务执行的间隔</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> period<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>DelayQueue</code>继承了<code>PriorityQueue</code>，</p> <blockquote><p>排序规则，order by time asc，order by sequenceNumber asc</p></blockquote> <p>对<code>DelayQueue</code>的<code>take()</code>和<code>add()</code>都要加锁。</p> <p><strong><code>task</code></strong></p> <ol><li>获取<code>Lock</code></li> <li>获取周期任务
<ul><li>如果队列为空，当前线程到<code>Condition</code>中<code>await</code>。否则执行下一条判断</li> <li>如果头元素的<code>time</code>比当前时间大，到<code>Condition</code>中<code>await</code>。否则执行下一条</li> <li>获取所有<code>time</code>小于等于当前时间的<code>FurtureTask</code>，唤醒<code>Condition</code>中等待的线程，并交付<code>FutureTask</code>执行。</li></ul></li> <li>释放<code>Lock</code></li></ol> <p><strong><code>add</code></strong></p> <ol><li>获取<code>Lock</code></li> <li>添加任务，如果任务满足执行条件，则唤醒<code>Condition</code>中等待的线程，交付执行。</li> <li>释放<code>Lock</code></li></ol> <h3 id="futuretask"><a href="#futuretask" class="header-anchor">#</a> <code>FutureTask</code></h3> <p><code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了接口<code>Runnable</code>。因此<code>FutureTask</code>可以交给<code>Executor</code>执行，也可以由调用线程直接执行（强转后调用<code>FutureTask.run()</code>）。</p> <p><code>FutureTask</code>有三种状态</p> <ol><li>未启动，<code>FutureTask.run()</code>未执行之前。</li> <li>已启动，<code>FutureTask.run()</code>的执行过程中。</li> <li>已完成，可以是正常结束，也可以是取消<code>Future.cancel(boolean mayInterruptIfRunning)</code>，也可以是因为抛出异常而结束。</li></ol> <blockquote><p>当<code>Future</code>处于未启动或已启动状态时，执行<code>Future.get()</code>方法将会导致调用线程阻塞；当<code>Future</code>处于已完成状态时，执行<code>Future.get()</code>方法将会导致调用线程立即返回结果或抛出异常。</p></blockquote> <h2 id="实战"><a href="#实战" class="header-anchor">#</a> 实战</h2> <h3 id="线上问题定位"><a href="#线上问题定位" class="header-anchor">#</a> 线上问题定位</h3> <h3 id="性能测试"><a href="#性能测试" class="header-anchor">#</a> 性能测试</h3></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/clinan/blog/edit/master/modules/technology/java/concurrent.md" target="_blank" rel="noopener noreferrer">Edit this page</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">7/15/2021, 9:28:34 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/modules/technology/java/java.html" class="prev">Java</a></span> <span class="next"><a href="/modules/technology/java/Netty.html">Netty</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c387313f.js" defer></script><script src="/assets/js/2.07d632c5.js" defer></script><script src="/assets/js/53.163cbc01.js" defer></script>
  </body>
</html>
